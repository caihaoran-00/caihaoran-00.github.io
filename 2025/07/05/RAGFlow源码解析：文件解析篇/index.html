<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"caihaoran-00.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言我们在前面一起体验了RAGFlow的效果，也接入Xinference本地部署的embedding&#x2F;reranker了，那么接下来我们就深入探索下RAGFlow的文件解析部分。它的文档解析部分被命名为DeepDoc，在RAGFlow中最常用的切割方法是General，本文将就General解析&#x2F;分块方式进行展开，着重关注pdf解析&#x2F;分块流程。">
<meta property="og:type" content="article">
<meta property="og:title" content="RAGFlow源码解析：文件解析篇">
<meta property="og:url" content="https://caihaoran-00.github.io/2025/07/05/RAGFlow%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E7%AF%87/index.html">
<meta property="og:site_name" content="Chr&#39;s Blog">
<meta property="og:description" content="前言我们在前面一起体验了RAGFlow的效果，也接入Xinference本地部署的embedding&#x2F;reranker了，那么接下来我们就深入探索下RAGFlow的文件解析部分。它的文档解析部分被命名为DeepDoc，在RAGFlow中最常用的切割方法是General，本文将就General解析&#x2F;分块方式进行展开，着重关注pdf解析&#x2F;分块流程。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-05T10:19:38.000Z">
<meta property="article:modified_time" content="2025-08-04T07:50:26.428Z">
<meta property="article:author" content="Chr">
<meta property="article:tag" content="rag">
<meta property="article:tag" content="pdf">
<meta property="article:tag" content="ragflow">
<meta property="article:tag" content="deepdoc">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://caihaoran-00.github.io/2025/07/05/RAGFlow%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E7%AF%87/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://caihaoran-00.github.io/2025/07/05/RAGFlow%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E7%AF%87/","path":"2025/07/05/RAGFlow源码解析：文件解析篇/","title":"RAGFlow源码解析：文件解析篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RAGFlow源码解析：文件解析篇 | Chr's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Chr's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Record and Share</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#naive-py"><span class="nav-number">2.1.</span> <span class="nav-text">naive.py</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pdf-PdfParser"><span class="nav-number">2.2.</span> <span class="nav-text">Pdf(PdfParser)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-images-%E2%80%A6"><span class="nav-number">2.3.</span> <span class="nav-text">self._images_(…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-ocr-%E2%80%A6"><span class="nav-number">2.4.</span> <span class="nav-text">self.__ocr(…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-layouts-rec-%E2%80%A6"><span class="nav-number">2.5.</span> <span class="nav-text">self._layouts_rec(…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-table-transformer-job-%E2%80%A6"><span class="nav-number">2.6.</span> <span class="nav-text">self._table_transformer_job(…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-text-merge"><span class="nav-number">2.7.</span> <span class="nav-text">self._text_merge()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-extract-table-figure-%E2%80%A6"><span class="nav-number">2.8.</span> <span class="nav-text">self._extract_table_figure(…)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F-separate-tables-figures-True"><span class="nav-number">2.8.1.</span> <span class="nav-text">分离模式 (separate_tables_figures&#x3D;True)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-concat-downward"><span class="nav-number">2.9.</span> <span class="nav-text">self._concat_downward()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self-line-tag-%E6%9C%80%E7%BB%88return"><span class="nav-number">2.10.</span> <span class="nav-text">self._line_tag()  &amp; 最终return</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">4.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chr</p>
  <div class="site-description" itemprop="description">Welcome to my little world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1299964565@qq.com" title="E-Mail → mailto:1299964565@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://caihaoran-00.github.io/2025/07/05/RAGFlow%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chr">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chr's Blog">
      <meta itemprop="description" content="Welcome to my little world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RAGFlow源码解析：文件解析篇 | Chr's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RAGFlow源码解析：文件解析篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-05 18:19:38" itemprop="dateCreated datePublished" datetime="2025-07-05T18:19:38+08:00">2025-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-04 15:50:26" itemprop="dateModified" datetime="2025-08-04T15:50:26+08:00">2025-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>58 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在前面一起体验了<code>RAGFlow</code>的效果，也<a href="https://caihaoran-00.github.io/2025/07/03/RAGFlow%EF%BC%9A%E6%8E%A5%E5%85%A5Xinference%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E7%9A%84embedding-reranker/">接入Xinference本地部署的embedding&#x2F;reranker</a>了，那么接下来我们就深入探索下<code>RAGFlow</code>的文件解析部分。它的文档解析部分被命名为<code>DeepDoc</code>，在<code>RAGFlow</code>中最常用的切割方法是<code>General</code>，本文将就<code>General</code>解析&#x2F;分块方式进行展开，着重关注<code>pdf</code>解析&#x2F;分块流程。</p>
<span id="more"></span>

<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>想要解析<code>General</code>分块方式，那么第一步就需要找到该分块方式对应的代码在哪个文件，打开<code>ragflow/rag/app</code>文件夹，可以看到：</p>
<p>对应了知识库配置中的切片方法：</p>
<ul>
<li>audio.py–&gt;?</li>
<li>book.py–&gt;Book</li>
<li>email.py–&gt;?</li>
<li>laws.py–&gt;Laws</li>
<li>manual.py–&gt;Manual</li>
<li>naive.py–&gt;?</li>
<li>one.py–&gt;One</li>
<li>paper.py–&gt;Paper</li>
<li>picture.py–&gt;?</li>
<li>presentation–&gt;Presentation.py</li>
<li>qa.py–&gt;Q&amp;A</li>
<li>resume.py–&gt;Resume</li>
<li>table.py–&gt;Tale</li>
<li>tag.py–&gt;Tag</li>
</ul>
<p>可以看出<code>ragflow/rag/app</code>文件夹下的<code>naive.py</code>与知识库配置中的<code>General</code>切片方法是都没有对应的，所以猜测他俩是对应的，但是又不能非常确定，经检索，发现<code>ragflow/rag/svr/task_executor.py</code>中有一段：</p>
<figure class="highlight python"><figcaption><span>task_executor.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FACTORY = &#123;</span><br><span class="line">    <span class="string">&quot;general&quot;</span>: naive,</span><br><span class="line">    ParserType.NAIVE.value: naive,</span><br><span class="line">    ParserType.PAPER.value: paper,</span><br><span class="line">    ParserType.BOOK.value: book,</span><br><span class="line">    ParserType.PRESENTATION.value: presentation,</span><br><span class="line">    ParserType.MANUAL.value: manual,</span><br><span class="line">    ParserType.LAWS.value: laws,</span><br><span class="line">    ParserType.QA.value: qa,</span><br><span class="line">    ParserType.TABLE.value: table,</span><br><span class="line">    ParserType.RESUME.value: resume,</span><br><span class="line">    ParserType.PICTURE.value: picture,</span><br><span class="line">    ParserType.ONE.value: one,</span><br><span class="line">    ParserType.AUDIO.value: audio,</span><br><span class="line">    ParserType.EMAIL.value: email,</span><br><span class="line">    ParserType.KG.value: naive,</span><br><span class="line">    ParserType.TAG.value: tag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以确定<code>naive.py</code>对应的就是<code>General</code>切分方式了，那么我们接下来就对<code>naive.py</code>进行解析。</p>
<hr>
<h3 id="naive-py"><a href="#naive-py" class="headerlink" title="naive.py"></a><code>naive.py</code></h3><p>文件位于<code>ragflow/rag/app/naive.py</code>，支持的文件种类众多：</p>
<p>它主要负责将各种格式的文档（如 DOCX、PDF、Excel、TXT 等）解析为文本内容，并将其分割成适合后续检索和处理的小块（chunks）便于后续处理。其中chunk函数是主入口函数，根据文件类型选择合适的解析器并执行分块操作，下面将着重解析chunk函数中的关于pdf解析相关的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chunk</span>(<span class="params">filename, binary=<span class="literal">None</span>, from_page=<span class="number">0</span>, to_page=<span class="number">100000</span>,</span></span><br><span class="line"><span class="params">          lang=<span class="string">&quot;Chinese&quot;</span>, callback=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Supported file formats are docx, pdf, excel, txt.</span></span><br><span class="line"><span class="string">        This method apply the naive ways to chunk files.</span></span><br><span class="line"><span class="string">        Successive text will be sliced into pieces using &#x27;delimiter&#x27;.</span></span><br><span class="line"><span class="string">        Next, these successive pieces are merge into chunks whose token number is no more than &#x27;Max token number&#x27;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    is_english = lang.lower() == <span class="string">&quot;english&quot;</span>  <span class="comment"># is_english(cks)</span></span><br><span class="line">    parser_config = kwargs.get(</span><br><span class="line">        <span class="string">&quot;parser_config&quot;</span>, &#123;</span><br><span class="line">            <span class="string">&quot;chunk_token_num&quot;</span>: <span class="number">128</span>, <span class="string">&quot;delimiter&quot;</span>: <span class="string">&quot;\n!?。；！？&quot;</span>, <span class="string">&quot;layout_recognize&quot;</span>: <span class="string">&quot;DeepDOC&quot;</span>&#125;)</span><br><span class="line">    doc = &#123;</span><br><span class="line">        <span class="string">&quot;docnm_kwd&quot;</span>: filename,</span><br><span class="line">        <span class="string">&quot;title_tks&quot;</span>: rag_tokenizer.tokenize(re.sub(<span class="string">r&quot;\.[a-zA-Z]+$&quot;</span>, <span class="string">&quot;&quot;</span>, filename))</span><br><span class="line">    &#125;</span><br><span class="line">    doc[<span class="string">&quot;title_sm_tks&quot;</span>] = rag_tokenizer.fine_grained_tokenize(doc[<span class="string">&quot;title_tks&quot;</span>])</span><br><span class="line">    res = []</span><br><span class="line">    pdf_parser = <span class="literal">None</span></span><br><span class="line">    section_images = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这是chunk函数的开始部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chunk</span>(<span class="params">filename, binary=<span class="literal">None</span>, from_page=<span class="number">0</span>, to_page=<span class="number">100000</span>,</span></span><br><span class="line"><span class="params">          lang=<span class="string">&quot;Chinese&quot;</span>, callback=<span class="literal">None</span>, **kwargs</span>):</span><br></pre></td></tr></table></figure>

<p>定义一个名为 chunk的函数，它接受以下参数：</p>
<ul>
<li><code>filename</code>: 文件名</li>
<li><code>binary</code>: 文件的二进制内容（可选）</li>
<li><code>from_page</code>: 起始页码，默认为0</li>
<li><code>to_page</code>: 结束页码，默认为100000</li>
<li><code>lang</code>: 语言，默认为”Chinese”</li>
<li><code>callback</code>: 回调函数，用于报告进度（可选）</li>
<li><code>**kwargs</code>: 其他关键字参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Supported file formats are docx, pdf, excel, txt.</span></span><br><span class="line"><span class="string">        This method apply the naive ways to chunk files.</span></span><br><span class="line"><span class="string">        Successive text will be sliced into pieces using &#x27;delimiter&#x27;.</span></span><br><span class="line"><span class="string">        Next, these successive pieces are merge into chunks whose token number is no more than &#x27;Max token 			number&#x27;.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>函数文档字符串，说明该函数支持的文件格式包括 docx、pdf、excel、txt，使用简单的方法对文件进行分块处理。它会使用分隔符将连续文本切片，然后将这些片段合并成令牌数不超过最大令牌数的块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_english = lang.lower() == <span class="string">&quot;english&quot;</span>  <span class="comment"># is_english(cks)</span></span><br></pre></td></tr></table></figure>

<p>判断文档是否为英文，通过将 lang参数转换为小写并与 “english” 比较，结果存储在 is_english变量中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser_config = kwargs.get(</span><br><span class="line">        <span class="string">&quot;parser_config&quot;</span>, &#123;</span><br><span class="line">            <span class="string">&quot;chunk_token_num&quot;</span>: <span class="number">128</span>, <span class="string">&quot;delimiter&quot;</span>: <span class="string">&quot;\n!?。；！？&quot;</span>, <span class="string">&quot;layout_recognize&quot;</span>: <span class="string">&quot;DeepDOC&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>从 <code>kwargs</code>中获取解析器配置，如果未提供则使用默认配置：</p>
<ul>
<li>chunk_token_num: 每个块的最大令牌数，默认为128</li>
<li>delimiter: 分隔符，默认为 “\n!?。；！？”</li>
<li>layout_recognize: 布局识别模式，默认为 “<code>DeepDOC</code>“</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doc = &#123;</span><br><span class="line">        <span class="string">&quot;docnm_kwd&quot;</span>: filename,</span><br><span class="line">        <span class="string">&quot;title_tks&quot;</span>: rag_tokenizer.tokenize(re.sub(<span class="string">r&quot;\.[a-zA-Z]+$&quot;</span>, <span class="string">&quot;&quot;</span>, filename))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建一个文档字典 doc，包含：</p>
<ul>
<li><code>docnm_kwd</code>: 文档名（完整文件名）</li>
<li><code>title_tks</code>: 文档标题的分词结果，通过正则表达式去除文件扩展名后进行分词</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc[<span class="string">&quot;title_sm_tks&quot;</span>] = rag_tokenizer.fine_grained_tokenize(doc[<span class="string">&quot;title_tks&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>为文档添加更细粒度的标题分词结果，存储在 <code>title_sm_tks</code> 字段中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br></pre></td></tr></table></figure>

<p>初始化一个空列表res，用于存储处理结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdf_parser = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>初始化 pdf_parser变量为 None，用于后续可能的 <code>PDF</code> 解析器实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section_images = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>初始化 <code>section_images</code>变量为 None，用于存储章节图像信息。</p>
<p>这段代码是<code>naive.py</code>中 <code>chunk</code>函数的初始化部分，主要完成以下任务：</p>
<ol>
<li>设置函数参数和默认值</li>
<li>确定文档语言</li>
<li>获取解析配置</li>
<li>初始化文档信息和结果容器</li>
</ol>
<p>接下来的代码会根据文件类型（通过文件扩展名判断）选择相应的处理逻辑，我们着重关注<code>pdf</code>文件的解析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> re.search(<span class="string">r&quot;\.pdf$&quot;</span>, filename, re.IGNORECASE):</span><br><span class="line">        layout_recognizer = parser_config.get(<span class="string">&quot;layout_recognize&quot;</span>, <span class="string">&quot;DeepDOC&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layout_recognizer, <span class="built_in">bool</span>):</span><br><span class="line">            layout_recognizer = <span class="string">&quot;DeepDOC&quot;</span> <span class="keyword">if</span> layout_recognizer <span class="keyword">else</span> <span class="string">&quot;Plain Text&quot;</span></span><br><span class="line">        callback(<span class="number">0.1</span>, <span class="string">&quot;Start to parse.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> layout_recognizer == <span class="string">&quot;DeepDOC&quot;</span>:</span><br><span class="line">            pdf_parser = Pdf()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                vision_model = LLMBundle(kwargs[<span class="string">&quot;tenant_id&quot;</span>], LLMType.IMAGE2TEXT)</span><br><span class="line">                callback(<span class="number">0.15</span>, <span class="string">&quot;Visual model detected. Attempting to enhance figure extraction...&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                vision_model = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> vision_model:</span><br><span class="line">                sections, tables, figures = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page, callback=callback, separate_tables_figures=<span class="literal">True</span>)</span><br><span class="line">                callback(<span class="number">0.5</span>, <span class="string">&quot;Basic parsing complete. Proceeding with figure enhancement...&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    pdf_vision_parser = VisionFigureParser(vision_model=vision_model, figures_data=figures, **kwargs)</span><br><span class="line">                    boosted_figures = pdf_vision_parser(callback=callback)</span><br><span class="line">                    tables.extend(boosted_figures)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    callback(<span class="number">0.6</span>, <span class="string">f&quot;Visual model error: <span class="subst">&#123;e&#125;</span>. Skipping figure parsing enhancement.&quot;</span>)</span><br><span class="line">                    tables.extend(figures)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sections, tables = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page, callback=callback)</span><br><span class="line"></span><br><span class="line">            res = tokenize_table(tables, doc, is_english)</span><br><span class="line">            callback(<span class="number">0.8</span>, <span class="string">&quot;Finish parsing.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> layout_recognizer == <span class="string">&quot;Plain Text&quot;</span>:</span><br><span class="line">                pdf_parser = PlainParser()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vision_model = LLMBundle(kwargs[<span class="string">&quot;tenant_id&quot;</span>], LLMType.IMAGE2TEXT, llm_name=layout_recognizer, lang=lang)</span><br><span class="line">                pdf_parser = VisionParser(vision_model=vision_model, **kwargs)</span><br><span class="line"></span><br><span class="line">            sections, tables = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page,</span><br><span class="line">                                          callback=callback)</span><br><span class="line">            res = tokenize_table(tables, doc, is_english)</span><br><span class="line">            callback(<span class="number">0.8</span>, <span class="string">&quot;Finish parsing.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我来逐行解释这段处理<code>PDF</code>文件的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> re.search(<span class="string">r&quot;\.pdf$&quot;</span>, filename, re.IGNORECASE):</span><br></pre></td></tr></table></figure>

<p>检查文件扩展名是否为”<code>.pdf</code>“（不区分大小写），如果是<code>PDF</code>文件则执行以下处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_recognizer = parser_config.get(<span class="string">&quot;layout_recognize&quot;</span>, <span class="string">&quot;DeepDOC&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>从解析配置中获取布局识别器类型，默认为”<code>DeepDOC</code>“。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(layout_recognizer, <span class="built_in">bool</span>):</span><br><span class="line">    layout_recognizer = <span class="string">&quot;DeepDOC&quot;</span> <span class="keyword">if</span> layout_recognizer <span class="keyword">else</span> <span class="string">&quot;Plain Text&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>layout_recognizer</code>是布尔值，则将其转换为字符串：”True”对应”<code>DeepDOC</code>“，”False”对应”<code>Plain Text</code>“。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(<span class="number">0.1</span>, <span class="string">&quot;Start to parse.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>调用回调函数报告进度，进度为10%，消息为”Start to parse.”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> layout_recognizer == <span class="string">&quot;DeepDOC&quot;</span>:</span><br></pre></td></tr></table></figure>

<p>如果使用”<code>DeepDOC</code>“布局识别模式，则执行以下处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdf_parser = Pdf()</span><br></pre></td></tr></table></figure>

<p>创建一个<code>Pdf</code>解析器实例，这是继承自<code>PdfParser</code>的自定义类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    vision_model = LLMBundle(kwargs[<span class="string">&quot;tenant_id&quot;</span>], LLMType.IMAGE2TEXT)</span><br><span class="line">    callback(<span class="number">0.15</span>, <span class="string">&quot;Visual model detected. Attempting to enhance figure extraction...&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    vision_model = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>尝试初始化视觉模型（用于图像内容理解），如果成功则报告进度15%，如果失败则将<code>vision_model</code>设为None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vision_model:</span><br></pre></td></tr></table></figure>

<p>如果成功初始化了视觉模型，则执行以下增强图像解析逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sections, tables, figures = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page, callback=callback, separate_tables_figures=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>调用<code>Pdf</code>解析器，传入文件名或二进制数据、页码范围、回调函数和<code>separate_tables_figures=True</code>参数。这个调用会返回三个值：<code>sections</code>（文本内容）、<code>tables</code>（表格）和<code>figures</code>（图像）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(<span class="number">0.5</span>, <span class="string">&quot;Basic parsing complete. Proceeding with figure enhancement...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>报告进度50%，消息为”Basic parsing complete. Proceeding with figure enhancement…”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pdf_vision_parser = VisionFigureParser(vision_model=vision_model, figures_data=figures, **kwargs)</span><br><span class="line">    boosted_figures = pdf_vision_parser(callback=callback)</span><br><span class="line">    tables.extend(boosted_figures)</span><br></pre></td></tr></table></figure>

<p>创建<code>VisionFigureParser</code>实例，使用视觉模型对提取的图像进行增强处理，然后将增强后的图像结果添加到<code>tables</code>列表中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    callback(<span class="number">0.6</span>, <span class="string">f&quot;Visual model error: <span class="subst">&#123;e&#125;</span>. Skipping figure parsing enhancement.&quot;</span>)</span><br><span class="line">    tables.extend(figures)</span><br></pre></td></tr></table></figure>

<p>如果视觉模型处理出错，则报告错误并将原始图像数据添加到<code>tables</code>列表中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sections, tables = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page, callback=callback)</span><br></pre></td></tr></table></figure>

<p>如果没有视觉模型，则直接调用<code>Pdf</code>解析器，不进行图像增强处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = tokenize_table(tables, doc, is_english)</span><br><span class="line">callback(<span class="number">0.8</span>, <span class="string">&quot;Finish parsing.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>tokenize_table</code>函数处理表格数据，将其转换为适合检索的格式（对<code>HTML</code>格式表格进行一定的信息提取与处理），并报告进度80%，消息为”Finish parsing.”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure>

<p>如果不是使用”<code>DeepDOC</code>“布局识别器，则执行以下逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> layout_recognizer == <span class="string">&quot;Plain Text&quot;</span>:</span><br><span class="line">    pdf_parser = PlainParser()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        vision_model = LLMBundle(kwargs[<span class="string">&quot;tenant_id&quot;</span>], LLMType.IMAGE2TEXT, llm_name=layout_recognizer, lang=lang)</span><br><span class="line">        pdf_parser = VisionParser(vision_model=vision_model, **kwargs)</span><br></pre></td></tr></table></figure>

<p>根据配置选择解析器：</p>
<ul>
<li>如果是”Plain Text”，使用<code>PlainParser</code>（基于<code>pypdf</code>的简单文本提取）</li>
<li>否则使用<code>VisionParser</code>（结合视觉模型的解析器）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sections, tables = pdf_parser(filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary, from_page=from_page, to_page=to_page,</span><br><span class="line">                              callback=callback)</span><br><span class="line">res = tokenize_table(tables, doc, is_english)</span><br><span class="line">callback(<span class="number">0.8</span>, <span class="string">&quot;Finish parsing.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>调用选定的解析器处理<code>PDF</code>，并使用<code>tokenize_table</code>处理表格数据，最后报告进度80%，消息为”Finish parsing.”。</p>
<p>这段代码处理<code>PDF</code>文档的解析，根据不同的布局识别配置选择不同的解析策略：</p>
<ol>
<li><code>DeepDOC</code>模式：使用高级<code>PDF</code>解析器，支持视觉模型增强图像理解</li>
<li>Plain Text模式：使用简单的文本提取方式</li>
<li>Vision模式：使用视觉模型进行内容理解</li>
</ol>
<p>每种模式都会提取文档的文本内容和表格，并最终将结果转换为适合检索的格式。</p>
<p><strong>还有最后一块代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">st = timer()</span><br><span class="line">    <span class="keyword">if</span> section_images:</span><br><span class="line">        <span class="comment"># if all images are None, set section_images to None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(image <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> image <span class="keyword">in</span> section_images):</span><br><span class="line">            section_images = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> section_images:</span><br><span class="line">        chunks, images = naive_merge_with_images(sections, section_images,</span><br><span class="line">                                        <span class="built_in">int</span>(parser_config.get(</span><br><span class="line">                                            <span class="string">&quot;chunk_token_num&quot;</span>, <span class="number">128</span>)), parser_config.get(</span><br><span class="line">                                            <span class="string">&quot;delimiter&quot;</span>, <span class="string">&quot;\n!?。；！？&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> kwargs.get(<span class="string">&quot;section_only&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">return</span> chunks</span><br><span class="line">        </span><br><span class="line">        res.extend(tokenize_chunks_with_images(chunks, doc, is_english, images))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        chunks = naive_merge(</span><br><span class="line">            sections, <span class="built_in">int</span>(parser_config.get(</span><br><span class="line">                <span class="string">&quot;chunk_token_num&quot;</span>, <span class="number">128</span>)), parser_config.get(</span><br><span class="line">                <span class="string">&quot;delimiter&quot;</span>, <span class="string">&quot;\n!?。；！？&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> kwargs.get(<span class="string">&quot;section_only&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line">        res.extend(tokenize_chunks(chunks, doc, is_english, pdf_parser))</span><br><span class="line">    </span><br><span class="line">    logging.info(<span class="string">&quot;naive_merge(&#123;&#125;): &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename, timer() - st))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这是<code>chunk</code>函数的结尾部分，主要负责将解析后的内容进行分块处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st = timer()</span><br></pre></td></tr></table></figure>

<p>记录当前时间，用于计算处理耗时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> section_images:</span><br><span class="line">    <span class="comment"># if all images are None, set section_images to None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(image <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> image <span class="keyword">in</span> section_images):</span><br><span class="line">        section_images = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>检查 <code>section_images</code> 是否存在，如果存在则进一步检查是否所有图像都为 None。如果是，则将 <code>section_images</code> 设置为 None，避免后续处理空图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> section_images:</span><br></pre></td></tr></table></figure>

<p>如果存在有效的图像数据，则执行以下带图像的分块处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunks, images = naive_merge_with_images(sections, section_images,</span><br><span class="line">                                        <span class="built_in">int</span>(parser_config.get(</span><br><span class="line">                                        <span class="string">&quot;chunk_token_num&quot;</span>, <span class="number">128</span>)), parser_config.get(</span><br><span class="line">                                        <span class="string">&quot;delimiter&quot;</span>, <span class="string">&quot;\n!?。；！？&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>调用 <code>naive_merge_with_images</code>函数，将文本内容和图像一起进行分块处理：</p>
<ul>
<li><code>sections</code>: 文本内容部分</li>
<li><code>section_images</code>: 图像数据</li>
<li><code>chunk_token_num</code>: 每个块的最大令牌数，默认128</li>
<li><code>delimiter</code>: 分隔符，默认为 “\n!?。；！？”</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> kwargs.get(<span class="string">&quot;section_only&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">return</span> chunks</span><br></pre></td></tr></table></figure>

<p>如果 <code>section_only</code>参数为 True，则只返回分块结果，不进行后续处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.extend(tokenize_chunks_with_images(chunks, doc, is_english, images))</span><br></pre></td></tr></table></figure>

<p>调用 <code>tokenize_chunks_with_images</code> 函数对分块结果进行标记化处理，并将结果添加到 <code>res</code> 列表中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure>

<p>如果没有图像数据，则执行不带图像的普通分块处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunks = naive_merge(</span><br><span class="line">    sections, <span class="built_in">int</span>(parser_config.get(</span><br><span class="line">        <span class="string">&quot;chunk_token_num&quot;</span>, <span class="number">128</span>)), parser_config.get(</span><br><span class="line">        <span class="string">&quot;delimiter&quot;</span>, <span class="string">&quot;\n!?。；！？&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>调用<code>naive_merge</code>函数对文本内容进行分块处理：</p>
<ul>
<li><code>sections</code>: 文本内容部分</li>
<li><code>chunk_token_num</code>: 每个块的最大令牌数，默认128</li>
<li><code>delimiter</code>: 分隔符，默认为 “\n!?。；！？”</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> kwargs.get(<span class="string">&quot;section_only&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">return</span> chunks</span><br></pre></td></tr></table></figure>

<p>如果 <code>section_only</code>参数为 True，则只返回分块结果，不进行后续处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.extend(tokenize_chunks(chunks, doc, is_english, pdf_parser))</span><br></pre></td></tr></table></figure>

<p>调用<code>tokenize_chunks</code>函数对分块结果进行标记化处理，并将结果添加到 <code>res</code> 列表中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.info(<span class="string">&quot;naive_merge(&#123;&#125;): &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename, timer() - st))</span><br></pre></td></tr></table></figure>

<p>记录日志，输出文件名和处理耗时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>返回最终的处理结果 <code>res</code>。</p>
<p>这段代码是 <code>naive.py</code>中 <code>chunk</code> 函数的最后阶段，主要功能是：</p>
<ol>
<li>对解析后的内容（文本和可能的图像）进行分块处理</li>
<li>根据是否包含图像选择不同的分块方法</li>
<li>对分块结果进行标记化处理，使其适用于后续的检索和问答任务</li>
<li>返回处理后的结果</li>
</ol>
<p>整个流程体现了 <code>RAGFlow</code> 对多模态内容（文本+图像）的统一处理能力，同时保持了对纯文本内容的高效处理。现在我们有了个总体的认识，下面我们将就其中的细节进行剖析。</p>
<hr>
<h3 id="Pdf-PdfParser"><a href="#Pdf-PdfParser" class="headerlink" title="Pdf(PdfParser)"></a><code>Pdf(PdfParser)</code></h3><p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pdf</span>(<span class="title class_ inherited__">PdfParser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, filename, binary=<span class="literal">None</span>, from_page=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">                 to_page=<span class="number">100000</span>, zoomin=<span class="number">3</span>, callback=<span class="literal">None</span>, separate_tables_figures=<span class="literal">False</span></span>):</span><br><span class="line">        start = timer()</span><br><span class="line">        first_start = start</span><br><span class="line">        callback(msg=<span class="string">&quot;OCR started&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.__images__(</span><br><span class="line">            filename <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">else</span> binary,</span><br><span class="line">            zoomin,</span><br><span class="line">            from_page,</span><br><span class="line">            to_page,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">        callback(msg=<span class="string">&quot;OCR finished (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line">        logging.info(<span class="string">&quot;OCR(&#123;&#125;~&#123;&#125;): &#123;:.2f&#125;s&quot;</span>.<span class="built_in">format</span>(from_page, to_page, timer() - start))</span><br><span class="line"></span><br><span class="line">        start = timer()</span><br><span class="line">        <span class="variable language_">self</span>._layouts_rec(zoomin)</span><br><span class="line">        callback(<span class="number">0.63</span>, <span class="string">&quot;Layout analysis (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line"></span><br><span class="line">        start = timer()</span><br><span class="line">        <span class="variable language_">self</span>._table_transformer_job(zoomin)</span><br><span class="line">        callback(<span class="number">0.65</span>, <span class="string">&quot;Table analysis (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line"></span><br><span class="line">        start = timer()</span><br><span class="line">        <span class="variable language_">self</span>._text_merge()</span><br><span class="line">        callback(<span class="number">0.67</span>, <span class="string">&quot;Text merged (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> separate_tables_figures:</span><br><span class="line">            tbls, figures = <span class="variable language_">self</span>._extract_table_figure(<span class="literal">True</span>, zoomin, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">            <span class="variable language_">self</span>._concat_downward()</span><br><span class="line">            logging.info(<span class="string">&quot;layouts cost: &#123;&#125;s&quot;</span>.<span class="built_in">format</span>(timer() - first_start))</span><br><span class="line">            <span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls, figures</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tbls = <span class="variable language_">self</span>._extract_table_figure(<span class="literal">True</span>, zoomin, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># self._naive_vertical_merge()</span></span><br><span class="line">            <span class="variable language_">self</span>._concat_downward()</span><br><span class="line">            <span class="comment"># self._filter_forpages()</span></span><br><span class="line">            logging.info(<span class="string">&quot;layouts cost: &#123;&#125;s&quot;</span>.<span class="built_in">format</span>(timer() - first_start))</span><br><span class="line">            <span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls</span><br></pre></td></tr></table></figure>

<p>这是 <code>Pdf</code>类的 <strong>call</strong> 方法，用于处理 <code>PDF</code> 文件的解析过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, filename, binary=<span class="literal">None</span>, from_page=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">             to_page=<span class="number">100000</span>, zoomin=<span class="number">3</span>, callback=<span class="literal">None</span>, separate_tables_figures=<span class="literal">False</span></span>):</span><br></pre></td></tr></table></figure>

<p>定义 <code>__call__</code> 方法，使类实例可以像函数一样被调用。参数包括：</p>
<ul>
<li><code>filename</code>: <code>PDF</code> 文件名</li>
<li><code>binary</code>: <code>PDF </code>文件的二进制内容（可选）</li>
<li><code>from_page</code>: 起始页码，默认为 0</li>
<li><code>to_page</code>: 结束页码，默认为 100000</li>
<li><code>zoomin</code>: 缩放因子，默认为 3</li>
<li><code>callback</code>: 回调函数，用于报告进度</li>
<li><code>separate_tables_figures</code>: 是否分离表格和图像，默认为 False</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line">first_start = start</span><br><span class="line">callback(msg=<span class="string">&quot;OCR started&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>记录开始时间，并通过回调函数报告 OCR 开始的消息。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.<span class="title function_ invoke__">__images__</span>(</span><br><span class="line">filename <span class="keyword">if</span> not <span class="keyword">binary</span> <span class="keyword">else</span> <span class="keyword">binary</span>,</span><br><span class="line">zoomin,</span><br><span class="line">from_page,</span><br><span class="line">to_page,</span><br><span class="line">callback</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>调用 <strong>images</strong>方法，将 <code>PDF</code> 页面转换为图像并进行 OCR 处理。根据是否提供 <code>binary</code> 参数选择使用文件名还是二进制内容。</p>
<p>在 <strong>images</strong>方法中：</p>
<ol>
<li>使用 <code>pdfplumber</code> 打开 <code>PDF</code> 文件</li>
<li>遍历指定页码范围内的页面</li>
<li>将每个页面转换为图像</li>
<li>使用 OCR 模型（如 <code>ppocr</code>）识别图像中的文本</li>
<li>将识别结果存储在 <code>boxes</code> 属性中</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callback(msg=<span class="string">&quot;OCR finished (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line">logging.info(<span class="string">&quot;OCR(&#123;&#125;~&#123;&#125;): &#123;:.2f&#125;s&quot;</span>.<span class="built_in">format</span>(from_page, to_page, timer() - start))</span><br></pre></td></tr></table></figure>

<p>OCR 完成后，通过回调函数报告完成消息和耗时，并记录日志。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line"><span class="variable language_">self</span>._layouts_rec(zoomin)</span><br><span class="line">callback(<span class="number">0.63</span>, <span class="string">&quot;Layout analysis (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br><span class="line">进行布局分析，识别文档中的文本、标题、表格等元素，然后通过回调函数报告布局分析的进度和耗时。</span><br></pre></td></tr></table></figure>

<p><code>_layouts_rec</code>方法会：</p>
<ol>
<li>使用布局识别模型分析每一页的布局</li>
<li>识别不同类型的区域（文本、标题、表格等）</li>
<li>将结果存储在<code>boxes</code>中</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line"><span class="variable language_">self</span>._table_transformer_job(zoomin)</span><br><span class="line">callback(<span class="number">0.65</span>, <span class="string">&quot;Table analysis (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br></pre></td></tr></table></figure>

<p>进行表格结构识别，然后通过回调函数报告表格分析的进度和耗时。</p>
<p><code>_table_transformer_job</code>方法会：</p>
<ol>
<li>使用表格识别模型检测和识别表格结构</li>
<li>提取表格中的文本内容</li>
<li>将表格信息添加到 <code>boxes</code>中</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line"><span class="variable language_">self</span>._text_merge()</span><br><span class="line">callback(<span class="number">0.67</span>, <span class="string">&quot;Text merged (&#123;:.2f&#125;s)&quot;</span>.<span class="built_in">format</span>(timer() - start))</span><br></pre></td></tr></table></figure>

<p>合并文本块，然后通过回调函数报告文本合并的进度和耗时。</p>
<p><code>text_merge</code>方法会：</p>
<ol>
<li>根据文本的位置和间距判断是否应该连接相邻的文本块</li>
<li>使用 XGBoost 模型进行智能判断</li>
<li>合并应该连接的文本块</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> separate_tables_figures:</span><br><span class="line">    tbls, figures = <span class="variable language_">self</span>._extract_table_figure(<span class="literal">True</span>, zoomin, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>._concat_downward()</span><br><span class="line">    logging.info(<span class="string">&quot;layouts cost: &#123;&#125;s&quot;</span>.<span class="built_in">format</span>(timer() - first_start))</span><br><span class="line">    <span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls, figures</span><br></pre></td></tr></table></figure>

<p>如果 <code>separate_tables_figures</code>为 True，则：</p>
<ol>
<li>调用 <code>_extract_table_figure</code>方法分别提取表格和图像</li>
<li>调用 <code>_concat_downward</code>方法进行纵向连接处理</li>
<li>记录总耗时日志</li>
<li>返回三个值：文本内容列表、表格列表、图像列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tbls = <span class="variable language_">self</span>._extract_table_figure(<span class="literal">True</span>, zoomin, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># self._naive_vertical_merge()</span></span><br><span class="line">    <span class="variable language_">self</span>._concat_downward()</span><br><span class="line">    <span class="comment"># self._filter_forpages()</span></span><br><span class="line">    logging.info(<span class="string">&quot;layouts cost: &#123;&#125;s&quot;</span>.<span class="built_in">format</span>(timer() - first_start))</span><br><span class="line">    <span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls</span><br></pre></td></tr></table></figure>

<p>如果<code>separate_tables_figures</code>为 False，则：</p>
<ol>
<li>调用 <code>_extract_table_figure</code>方法提取表格（不分离图像）</li>
<li>调用<code>_concat_downward</code>方法进行纵向连接处理</li>
<li>记录总耗时日志</li>
<li>返回两个值：文本内容列表、表格列表</li>
</ol>
<p><strong>总结：</strong></p>
<p>这个 <strong>call</strong>方法是 <code>PDF</code> 解析的核心流程，它按顺序执行以下步骤：</p>
<ol>
<li>OCR 处理：将 <code>PD</code>F 页面转换为图像并识别文本</li>
<li>布局分析：识别文档结构</li>
<li>表格分析：识别和结构化表格内容</li>
<li>文本合并：智能合并相关文本块</li>
<li>提取表格和图像：根据参数决定是否分离表格和图像</li>
<li>纵向连接处理：进一步优化文本块连接</li>
<li>返回解析结果：包括文本内容、表格和可能的图像</li>
</ol>
<p>整个过程体现了 <code>RAGFlow </code>对 <code>PDF</code> 文档的深度解析能力，特别适合处理复杂格式的 <code>PDF</code> 文件。</p>
<hr>
<h3 id="self-images-…"><a href="#self-images-…" class="headerlink" title="self._images_(…)"></a>self._<em>images</em>_(…)</h3><p>这是<code>PdfParser</code>类中的<code>__images__</code>方法，负责处理<code>PDF</code>文档的图像转换和<code>OCR</code>识别。该方法是<code>RAGFlow</code>的 <code>PDF</code>解析流程中的第一步，主要负责以下功能：</p>
<p><strong>1. 初始化数据结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.lefted_chars = []</span><br><span class="line"><span class="variable language_">self</span>.mean_height = []</span><br><span class="line"><span class="variable language_">self</span>.mean_width = []</span><br><span class="line"><span class="variable language_">self</span>.boxes = []</span><br><span class="line"><span class="variable language_">self</span>.garbages = &#123;&#125;</span><br><span class="line"><span class="variable language_">self</span>.page_cum_height = [<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">self</span>.page_layout = []</span><br><span class="line"><span class="variable language_">self</span>.page_from = page_from</span><br></pre></td></tr></table></figure>

<p>这些变量用于存储解析过程中的各种数据：</p>
<ul>
<li><p><code>lefted_chars</code>：剩余字符</p>
</li>
<li><p><code>mean_height</code>和<code>mean_width</code>：页面字符的平均高度和宽度</p>
</li>
<li><p><code>boxes</code>：文本块存储列表</p>
<blockquote>
<p>这是存储文本块的核心数据结构。每个”box”代表一个文本块，包含以下信息：</p>
<ul>
<li>文本内容</li>
<li>位置坐标（x0, x1, top, bottom）</li>
<li>页码信息</li>
<li>布局类型（文本、标题、表格等）</li>
<li>其他元数据</li>
</ul>
</blockquote>
</li>
<li><p><code>garbages</code>：无关的内容</p>
<blockquote>
<p>这个字典用于存储被认为是”垃圾”或不需要的内容。在文档解析过程中，一些被识别为无关紧要的内容（如页眉、页脚、页码等）会被分类到这个集合中，以避免干扰主要文本内容的处理。</p>
</blockquote>
</li>
<li><p><code>page_cum_height</code>：页面累积高度列表</p>
</li>
<li><p><code>page_layout</code>：页面布局信息</p>
</li>
<li><p><code>page_from</code>：开始处理的页码</p>
</li>
</ul>
<p><strong>2. <code>PDF</code>页面转图像</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> sys.modules[LOCK_KEY_pdfplumber]:</span><br><span class="line">    <span class="keyword">with</span> (pdfplumber.<span class="built_in">open</span>(fnm) <span class="keyword">if</span> <span class="built_in">isinstance</span>(fnm, <span class="built_in">str</span>) <span class="keyword">else</span> pdfplumber.<span class="built_in">open</span>(BytesIO(fnm))) <span class="keyword">as</span> pdf:</span><br><span class="line">        <span class="variable language_">self</span>.pdf = pdf</span><br><span class="line">        <span class="variable language_">self</span>.page_images = [p.to_image(resolution=<span class="number">72</span> * zoomin, antialias=<span class="literal">True</span>).annotated <span class="keyword">for</span> i, p <span class="keyword">in</span></span><br><span class="line">                            <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.pdf.pages[page_from:page_to])]</span><br></pre></td></tr></table></figure>

<p>这部分使用<code>pdfplumber</code>库：</p>
<ul>
<li>将<code>PDF</code>页面转换为图像，分辨率为<code>72 * zoomin</code></li>
<li><code>antialias</code>参数设置为True，表示启用抗锯齿，对于文本图像特别重要，可以减少OCR识别错误</li>
<li><code>zoomin</code>参数控制放大倍数，默认为3倍</li>
<li>只处理指定范围的页面（<code>page_from</code>到<code>page_to</code>）</li>
<li>i是枚举索引，表示当前处理的是第几个页面（相对于切片的索引），p是当前页面对象</li>
<li>将生成的所有页面图像存储在<code>self.page_images</code>列表中，每个元素是一个<code>PIL Image</code>对象，代表对应<code>PDF</code>页面的图像</li>
</ul>
<p><strong>3. 字符提取和预处理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="variable language_">self</span>.page_chars = [[c <span class="keyword">for</span> c <span class="keyword">in</span> page.dedupe_chars().chars <span class="keyword">if</span> <span class="variable language_">self</span>._has_color(c)] <span class="keyword">for</span> page <span class="keyword">in</span> <span class="variable language_">self</span>.pdf.pages[page_from:page_to]]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.warning(<span class="string">f&quot;Failed to extract characters for pages <span class="subst">&#123;page_from&#125;</span>-<span class="subst">&#123;page_to&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.page_chars = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(page_to - page_from)]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>dedupe_chars()</code>方法去除重复字符</li>
<li>通过<code>_has_color</code>方法过滤掉不需要的字符（如纯白的<code>DeviceGray</code>字符）</li>
<li>如果提取失败，则使用空列表代替</li>
</ul>
<blockquote>
<p>假设一个简单的PDF文档有两页，内容如下：</p>
<p>第1页：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="attribute">page</span> <span class="number">1</span></span><br><span class="line">Second <span class="selector-tag">line</span> of <span class="selector-tag">text</span></span><br></pre></td></tr></table></figure>

<p>第2页：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="attribute">page</span> <span class="number">2</span></span><br><span class="line">Another <span class="selector-tag">line</span> here</span><br></pre></td></tr></table></figure>

<p><code>self.page_chars</code>的内容可能如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="comment"># 第1页的字符列表</span></span><br><span class="line">    [</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">72.0</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">79.2</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">7.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;h&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">79.2</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">86.4</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">7.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;i&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">86.4</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">89.6</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">3.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">89.6</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">96.0</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">6.4</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot; &quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">96.0</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">4.0</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;i&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">103.2</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">3.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        <span class="comment"># ... (第1页其余字符)</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 第2页的字符列表</span></span><br><span class="line">    [</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">72.0</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">79.2</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">7.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;h&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">79.2</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">86.4</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">7.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;i&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">86.4</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">89.6</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">3.2</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">89.6</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">96.0</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">112.0</span>, <span class="string">&quot;width&quot;</span>: <span class="number">6.4</span>, <span class="string">&quot;height&quot;</span>: <span class="number">12.0</span>, ...&#125;,</span><br><span class="line">        <span class="comment"># ... (第2页其余字符)</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>4. <code>PDF</code>大纲提取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> (pdf2_read(fnm <span class="keyword">if</span> <span class="built_in">isinstance</span>(fnm, <span class="built_in">str</span>)</span><br><span class="line">                    <span class="keyword">else</span> BytesIO(fnm))) <span class="keyword">as</span> pdf:</span><br><span class="line">        <span class="variable language_">self</span>.pdf = pdf</span><br><span class="line">        outlines = <span class="variable language_">self</span>.pdf.outline</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">arr, depth</span>):</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">dict</span>):</span><br><span class="line">                    <span class="variable language_">self</span>.outlines.append((a[<span class="string">&quot;/Title&quot;</span>], depth))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(a, depth + <span class="number">1</span>)</span><br><span class="line">        dfs(outlines, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.warning(<span class="string">f&quot;Outlines exception: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>pypdf</code>库提取<code>PDF</code>大纲（目录）信息，通过<code>DFS</code>算法遍历大纲树结构。</p>
<p><strong>5. 语言检测</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.is_english = [re.search(<span class="string">r&quot;[a-zA-Z0-9,/¸;:&#x27;\[\]\(\)!@#$%^&amp;*\&quot;?&lt;&gt;._-]&#123;30,&#125;&quot;</span>, <span class="string">&quot;&quot;</span>.join(</span><br><span class="line">    random.choices([c[<span class="string">&quot;text&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.page_chars[i]], k=<span class="built_in">min</span>(<span class="number">100</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.page_chars[i]))))) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.page_chars))]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">if</span> e <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> e <span class="keyword">in</span> <span class="variable language_">self</span>.is_english]) &gt; <span class="built_in">len</span>(</span><br><span class="line">        <span class="variable language_">self</span>.page_images) / <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">self</span>.is_english = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="variable language_">self</span>.is_english = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>通过正则表达式检测文档是否为英文，如果超过一半页面检测为英文，则整体标记为英文文档。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.is_english = [re.search(<span class="string">r&quot;[a-zA-Z0-9,/¸;:&#x27;\[\]\(\)!@#$%^&amp;*\&quot;?&lt;&gt;._-]&#123;30,&#125;&quot;</span>, <span class="string">&quot;&quot;</span>.join(</span><br><span class="line">            random.choices([c[<span class="string">&quot;text&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.page_chars[i]], k=<span class="built_in">min</span>(<span class="number">100</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.page_chars[i]))))) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.page_chars))]</span><br></pre></td></tr></table></figure>

<p>这是一个复杂的列表推导式，让我们逐步解析：</p>
<p><strong>数据源提取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c[<span class="string">&quot;text&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.page_chars[i]]</span><br></pre></td></tr></table></figure>

<ul>
<li>从<code>self.page_chars</code>中提取第<code>i</code>页的所有字符文本</li>
<li><code>self.page_chars</code>是在前面步骤中通过<code>PDF</code>解析提取的字符信息列表</li>
</ul>
<p><strong>随机抽样</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.choices([c[<span class="string">&quot;text&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.page_chars[i]], k=<span class="built_in">min</span>(<span class="number">100</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.page_chars[i])))</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>random.choices</code>从每页字符中随机抽取最多100个字符</li>
<li>如果该页字符数少于100个，则抽取所有字符</li>
<li>这种抽样方法可以提高检测效率，避免处理大量数据</li>
</ul>
<p><strong>字符合并</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.join(...)</span><br></pre></td></tr></table></figure>

<ul>
<li>将抽样的字符文本连接成一个字符串</li>
</ul>
<p><strong>正则表达式检测</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(<span class="string">r&quot;[a-zA-Z0-9,/¸;:&#x27;\[\]\(\)!@#$%^&amp;*\&quot;?&lt;&gt;._-]&#123;30,&#125;&quot;</span>, ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用正则表达式检测连续的英文字符和数字</li>
<li>模式解释：<ul>
<li><code>[a-zA-Z0-9,/¸;:&#39;\[\]\(\)!@#$%^&amp;*\&quot;?&lt;&gt;._-]</code>：匹配英文字母、数字和常见符号</li>
<li><code>&#123;30,&#125;</code>：要求至少连续30个字符匹配</li>
</ul>
</li>
<li>如果找到匹配项，说明该页可能包含大量英文内容</li>
</ul>
<p><strong>结果存储</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.is_english = [...]  <span class="comment"># 每页的检测结果列表</span></span><br></pre></td></tr></table></figure>

<ul>
<li>存储每页的检测结果</li>
<li>每个元素是匹配结果对象（如果匹配成功）或None（如果匹配失败）</li>
</ul>
<p><strong>整体语言判断</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">if</span> e <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> e <span class="keyword">in</span> <span class="variable language_">self</span>.is_english]) &gt; <span class="built_in">len</span>(</span><br><span class="line">        <span class="variable language_">self</span>.page_images) / <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">self</span>.is_english = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="variable language_">self</span>.is_english = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>统计英文页面数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">if</span> e <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> e <span class="keyword">in</span> <span class="variable language_">self</span>.is_english])</span><br></pre></td></tr></table></figure>

<ul>
<li>将每页的检测结果转换为数值（匹配成功为1，失败为0）</li>
<li>求和得到检测为英文的页面数量</li>
</ul>
<p><strong>判断标准</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.page_images) / <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果超过一半页面检测为英文，则整个文档标记为英文</li>
<li>否则标记为非英文（可能是中文或其他语言）</li>
</ul>
<p>在后续的OCR处理中，这个判断结果会影响处理策略：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python<span class="keyword">def</span> <span class="title function_">__ocr_preprocess</span>():</span><br><span class="line">    chars = <span class="variable language_">self</span>.page_chars[i] <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_english <span class="keyword">else</span> []</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于英文文档，可能更多依赖OCR识别而非已有字符信息</li>
<li>对于非英文文档，会更多利用已提取的字符信息</li>
</ul>
</blockquote>
<p><strong>6. OCR处理</strong></p>
<p>方法中定义了<code>__img_ocr</code>和<code>__img_ocr_launcher</code>两个内部函数来处理OCR，这段代码是<code>__images__</code>方法中的核心部分：</p>
<p><strong>1. <code>__img_ocr</code>函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__img_ocr</span>(<span class="params">i, <span class="built_in">id</span>, img, chars, limiter</span>):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j + <span class="number">1</span> &lt; <span class="built_in">len</span>(chars):</span><br><span class="line">        <span class="keyword">if</span> chars[j][<span class="string">&quot;text&quot;</span>] <span class="keyword">and</span> chars[j + <span class="number">1</span>][<span class="string">&quot;text&quot;</span>] \</span><br><span class="line">                <span class="keyword">and</span> re.<span class="keyword">match</span>(<span class="string">r&quot;[0-9a-zA-Z,.:;!%]+&quot;</span>, chars[j][<span class="string">&quot;text&quot;</span>] + chars[j + <span class="number">1</span>][<span class="string">&quot;text&quot;</span>]) \</span><br><span class="line">                <span class="keyword">and</span> chars[j + <span class="number">1</span>][<span class="string">&quot;x0&quot;</span>] - chars[j][<span class="string">&quot;x1&quot;</span>] &gt;= <span class="built_in">min</span>(chars[j + <span class="number">1</span>][<span class="string">&quot;width&quot;</span>],</span><br><span class="line">                                                               chars[j][<span class="string">&quot;width&quot;</span>]) / <span class="number">2</span>:</span><br><span class="line">            chars[j][<span class="string">&quot;text&quot;</span>] += <span class="string">&quot; &quot;</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> limiter:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> limiter:</span><br><span class="line">            <span class="keyword">await</span> trio.to_thread.run_sync(<span class="keyword">lambda</span>: <span class="variable language_">self</span>.__ocr(i + <span class="number">1</span>, img, chars, zoomin, <span class="built_in">id</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.__ocr(i + <span class="number">1</span>, img, chars, zoomin, <span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">and</span> i % <span class="number">6</span> == <span class="number">5</span>:</span><br><span class="line">        callback(prog=(i + <span class="number">1</span>) * <span class="number">0.6</span> / <span class="built_in">len</span>(<span class="variable language_">self</span>.page_images), msg=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数负责单个页面的OCR处理：</p>
<ol>
<li><strong>字符间距处理</strong>：<ul>
<li>遍历相邻的字符对</li>
<li>如果两个字符都是英文字母数字，并且它们之间有足够的间距（大于字符宽度的一半）</li>
<li>则在第一个字符后添加空格，以正确分隔单词</li>
</ul>
</li>
<li><strong>执行OCR</strong>：<ul>
<li>如果有<code>limiter</code>（并行限制器），则在限制器内异步执行OCR</li>
<li>否则直接执行OCR</li>
<li>使用<code>trio.to_thread.run_sync</code>将OCR任务放到线程中执行，避免阻塞异步事件循环</li>
</ul>
</li>
<li><strong>进度回调</strong>：<ul>
<li>每处理6页就调用一次回调函数报告进度</li>
<li>进度计算为：<code>(已处理页数) * 0.6 / (总页数)</code>，表示OCR占整个流程60%的进度</li>
</ul>
</li>
</ol>
<p><strong>2. <code>__img_ocr_launcher</code>函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__img_ocr_launcher</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ocr_preprocess</span>():</span><br><span class="line">        chars = <span class="variable language_">self</span>.page_chars[i] <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_english <span class="keyword">else</span> []</span><br><span class="line">        <span class="variable language_">self</span>.mean_height.append(</span><br><span class="line">            np.median(<span class="built_in">sorted</span>([c[<span class="string">&quot;height&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> chars])) <span class="keyword">if</span> chars <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.mean_width.append(</span><br><span class="line">            np.median(<span class="built_in">sorted</span>([c[<span class="string">&quot;width&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> chars])) <span class="keyword">if</span> chars <span class="keyword">else</span> <span class="number">8</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.page_cum_height.append(img.size[<span class="number">1</span>] / zoomin)</span><br><span class="line">        <span class="keyword">return</span> chars</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.parallel_limiter:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> trio.open_nursery() <span class="keyword">as</span> nursery:</span><br><span class="line">            <span class="keyword">for</span> i, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.page_images):</span><br><span class="line">                chars = __ocr_preprocess()</span><br><span class="line"></span><br><span class="line">                nursery.start_soon(__img_ocr, i, i % PARALLEL_DEVICES, img, chars,</span><br><span class="line">                                   <span class="variable language_">self</span>.parallel_limiter[i % PARALLEL_DEVICES])</span><br><span class="line">                <span class="keyword">await</span> trio.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.page_images):</span><br><span class="line">            chars = __ocr_preprocess()</span><br><span class="line">            <span class="keyword">await</span> __img_ocr(i, <span class="number">0</span>, img, chars, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数负责启动和协调所有页面的OCR处理：</p>
<ol>
<li><p><code>__ocr_preprocess</code>内部函数：</p>
<ul>
<li>为英文文档设置空的字符列表（因为英文文档主要依赖OCR识别）</li>
<li>计算页面字符的平均高度和宽度</li>
<li>更新累积页面高度列表</li>
</ul>
</li>
<li><p><strong>并行处理</strong>：</p>
<ul>
<li>如果有<code>parallel_limiter</code>（并行设备数大于1），使用<code>trio.open_nursery()</code>创建任务组并行处理</li>
<li>否则顺序处理每一页</li>
<li>使用<code>nursery.start_soon()</code>启动并行任务</li>
<li>在任务之间添加短暂延迟避免资源竞争</li>
</ul>
</li>
<li><p>执行流程</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trio.run(__img_ocr_launcher)</span><br></pre></td></tr></table></figure>

<p>使用trio运行时执行<code>__img_ocr_launcher</code>函数，处理所有页面的OCR。</p>
<p><strong>功能特点</strong></p>
<ol>
<li><strong>智能空格处理</strong>：自动检测英文字符间的合理空格，提高OCR文本质量</li>
<li><strong>并行处理</strong>：支持多线程并行OCR，提高处理速度</li>
<li><strong>进度报告</strong>：定期向调用方报告处理进度</li>
<li><strong>自适应处理</strong>：根据文档是否为英文调整处理策略</li>
<li><strong>统计信息收集</strong>：收集字符尺寸统计信息，用于后续处理</li>
</ol>
<p><strong>总结</strong></p>
<p>这段代码实现了<code>PDF</code>文档OCR处理的核心逻辑，通过异步和并行处理提高效率，同时通过智能字符处理提升OCR结果质量。它是<code>RAGFlow</code>文档解析流程中的关键步骤，为后续的布局分析和内容提取提供基础文本数据。</p>
<p><strong>7. 自适应缩放处理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.boxes) == <span class="number">0</span> <span class="keyword">and</span> zoomin &lt; <span class="number">9</span>:</span><br><span class="line">    <span class="variable language_">self</span>.__images__(fnm, zoomin * <span class="number">3</span>, page_from, page_to, callback)</span><br></pre></td></tr></table></figure>

<p>如果未检测到文本框且缩放因子小于9，则自动以3倍缩放重试，确保能够正确识别文档内容。</p>
<hr>
<p><strong>总结</strong></p>
<p><code>__images</code>方法是<code>RAGFlow</code>的<code>PDF</code>解析流程的核心起点，它整合了：</p>
<ol>
<li><code>PDF</code>页面到图像的转换</li>
<li>字符信息提取</li>
<li>文档结构（大纲）提取</li>
<li>语言检测</li>
<li>OCR文本识别</li>
<li>自适应缩放处理</li>
</ol>
<p>这个方法为后续的布局分析、表格识别和文本处理提供了基础数据。通过并行处理和自适应缩放，确保了对各种<code>PDF</code>文档的高精度解析。</p>
<hr>
<h3 id="self-ocr-…"><a href="#self-ocr-…" class="headerlink" title="self.__ocr(…)"></a>self.__ocr(…)</h3><p><strong>方法详解</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__ocr</span>(<span class="params">self, pagenum, img, chars, ZM=<span class="number">3</span>, device_id: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure>

<p><strong>方法签名和参数</strong></p>
<ul>
<li><strong>pagenum</strong>: 页码（从1开始）</li>
<li><strong>img</strong>: 页面图像对象</li>
<li><strong>chars</strong>: 从PDF中提取的字符信息列表</li>
<li><strong>ZM</strong>: 缩放因子，默认为3</li>
<li><strong>device_id</strong>: 设备ID，用于指定GPU设备（可为None）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line">bxs = <span class="variable language_">self</span>.ocr.detect(np.array(img), device_id)</span><br><span class="line">logging.info(<span class="string">f&quot;__ocr detecting boxes of a image cost (<span class="subst">&#123;timer() - start&#125;</span>s)&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bxs的数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bxs = [</span><br><span class="line">    <span class="comment"># 每个元素代表一个检测到的文本行</span></span><br><span class="line">    (</span><br><span class="line">        <span class="comment"># 文本行的边界框坐标 (4个点的坐标)</span></span><br><span class="line">        [</span><br><span class="line">            [x0, y0],  <span class="comment"># 左上角</span></span><br><span class="line">            [x1, y1],  <span class="comment"># 右上角</span></span><br><span class="line">            [x2, y2],  <span class="comment"># 右下角</span></span><br><span class="line">            [x3, y3]   <span class="comment"># 左下角</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment"># 识别结果，包含文本和置信度</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;识别的文本内容&quot;</span>,</span><br><span class="line">            置信度  <span class="comment"># 通常是0到1之间的浮点数</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># ... 更多检测到的文本行</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>文本检测</strong></p>
<ol>
<li>记录开始时间</li>
<li>使用OCR检测器检测图像中的文本框<ul>
<li>将PIL图像转换为numpy数组</li>
<li>调用<code>self.ocr.detect</code>方法进行文本检测</li>
</ul>
</li>
<li>记录并打印检测耗时</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = timer()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> bxs:</span><br><span class="line">    <span class="variable language_">self</span>.boxes.append([])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>检查检测结果</strong></p>
<ul>
<li>如果没有检测到文本框，将空列表添加到<code>self.boxes</code>并返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bxs = [(line[<span class="number">0</span>], line[<span class="number">1</span>][<span class="number">0</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> bxs]</span><br></pre></td></tr></table></figure>

<p><strong>格式化检测结果</strong></p>
<ul>
<li>将检测结果转换为更简单的格式：[(边界框坐标, 文本内容), …](不要置信度了)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bxs = Recognizer.sort_Y_firstly(</span><br><span class="line">    [&#123;<span class="string">&quot;x0&quot;</span>: b[<span class="number">0</span>][<span class="number">0</span>] / ZM, <span class="string">&quot;x1&quot;</span>: b[<span class="number">1</span>][<span class="number">0</span>] / ZM,</span><br><span class="line">      <span class="string">&quot;top&quot;</span>: b[<span class="number">0</span>][<span class="number">1</span>] / ZM, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;txt&quot;</span>: t,</span><br><span class="line">      <span class="string">&quot;bottom&quot;</span>: b[-<span class="number">1</span>][<span class="number">1</span>] / ZM,</span><br><span class="line">      <span class="string">&quot;chars&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;page_number&quot;</span>: pagenum&#125; <span class="keyword">for</span> b, t <span class="keyword">in</span> bxs <span class="keyword">if</span> b[<span class="number">0</span>][<span class="number">0</span>] &lt;= b[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> b[<span class="number">0</span>][<span class="number">1</span>] &lt;= b[-<span class="number">1</span>][<span class="number">1</span>]],</span><br><span class="line">    <span class="variable language_">self</span>.mean_height[pagenum-<span class="number">1</span>] / <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bxs数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理后的bxs（过滤掉无效框，转换坐标，按Y轴排序）</span></span><br><span class="line">bxs = [</span><br><span class="line">    &#123;  <span class="comment"># 第一行（Y坐标较小）</span></span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: <span class="number">400.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: <span class="number">200.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;bottom&quot;</span>: <span class="number">220.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;txt&quot;</span>: <span class="string">&quot;这是第一行文本&quot;</span>,</span><br><span class="line">        <span class="string">&quot;chars&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;  <span class="comment"># 第二行（Y坐标较大）</span></span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: <span class="number">300.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: <span class="number">300.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;bottom&quot;</span>: <span class="number">320.0</span>/ZM,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;txt&quot;</span>: <span class="string">&quot;第二行文本&quot;</span>,</span><br><span class="line">        <span class="string">&quot;chars&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 第三个无效框被过滤掉</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>使用<code>sort_Y_firstly</code>方法按Y轴坐标排序：</p>
<ul>
<li>第一个参数：待排序的文本框列表</li>
<li>第二个参数：排序阈值，设置为当前页平均字符高度的1&#x2F;3</li>
<li>这个方法会优先按Y坐标排序，当Y坐标差异小于阈值时再按X坐标排序</li>
</ul>
</blockquote>
<p><strong>创建文本框对象并按Y轴排序</strong></p>
<ol>
<li>为每个检测到的文本框创建字典对象，包含：<ul>
<li><code>x0</code>, <code>x1</code>: 左右边界坐标（除以缩放因子<code>ZM</code>进行还原）</li>
<li><code>top</code>, <code>bottom</code>: 上下边界坐标</li>
<li><code>text</code>: 识别文本（初始为空）</li>
<li><code>txt</code>: 检测器返回的原始文本</li>
<li><code>chars</code>: 关联的<code>PDF</code>字符（初始为空列表）</li>
<li><code>page_number</code>: 页码</li>
</ul>
</li>
<li>过滤掉无效的边界框（左边界大于右边界或上边界大于下边界的框）</li>
<li>使用<code>Recognizer.sort_Y_firstly</code>按Y轴坐标排序，排序阈值为平均字符高度的1&#x2F;3</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># merge chars in the same rect</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> chars:</span><br><span class="line">    ii = Recognizer.find_overlapped(c, bxs)</span><br><span class="line">    <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.lefted_chars.append(c)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ch = c[<span class="string">&quot;bottom&quot;</span>] - c[<span class="string">&quot;top&quot;</span>]		<span class="comment"># 字符高度</span></span><br><span class="line">    bh = bxs[ii][<span class="string">&quot;bottom&quot;</span>] - bxs[ii][<span class="string">&quot;top&quot;</span>]		<span class="comment"># 文本框高度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(ch - bh) / <span class="built_in">max</span>(ch, bh) &gt;= <span class="number">0.7</span> <span class="keyword">and</span> c[<span class="string">&quot;text&quot;</span>] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">        <span class="variable language_">self</span>.lefted_chars.append(c)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    bxs[ii][<span class="string">&quot;chars&quot;</span>].append(c)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bxs数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: <span class="number">178</span>,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;txt&quot;</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">        <span class="string">&quot;chars&quot;</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;H&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">100</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">108</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">108</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">116</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">116</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">122</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">122</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">128</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;o&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">128</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">136</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot; &quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">136</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">140</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;W&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">140</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">150</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;o&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">150</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">158</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;r&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">158</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">164</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">164</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">170</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;text&quot;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&quot;x0&quot;</span>: <span class="number">170</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">178</span>, <span class="string">&quot;top&quot;</span>: <span class="number">200</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">212</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>将<code>PDF</code>字符合并到OCR文本框中</strong></p>
<ol>
<li>遍历所有从<code>PDF</code>中提取的字符</li>
<li>使用<code>Recognizer.find_overlapped</code>查找与字符重叠的OCR文本框</li>
<li>如果没有找到重叠框，将字符添加到<code>lefted_chars</code></li>
<li>检查字符高度与文本框高度的差异：<ul>
<li>如果高度差异超过70%且字符不是空格，则将字符添加到<code>lefted_chars</code></li>
</ul>
</li>
<li>否则将字符添加到对应文本框的<code>chars</code>列表中</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> bxs:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b[<span class="string">&quot;chars&quot;</span>]:</span><br><span class="line">        <span class="keyword">del</span> b[<span class="string">&quot;chars&quot;</span>]</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    m_ht = np.mean([c[<span class="string">&quot;height&quot;</span>] <span class="keyword">for</span> c <span class="keyword">in</span> b[<span class="string">&quot;chars&quot;</span>]])</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> Recognizer.sort_Y_firstly(b[<span class="string">&quot;chars&quot;</span>], m_ht):</span><br><span class="line">        <span class="keyword">if</span> c[<span class="string">&quot;text&quot;</span>] == <span class="string">&quot; &quot;</span> <span class="keyword">and</span> b[<span class="string">&quot;text&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&quot;[0-9a-zA-Zа-яА-Я,.?;:!%%]&quot;</span>, b[<span class="string">&quot;text&quot;</span>][-<span class="number">1</span>]):</span><br><span class="line">                b[<span class="string">&quot;text&quot;</span>] += <span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b[<span class="string">&quot;text&quot;</span>] += c[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    <span class="keyword">del</span> b[<span class="string">&quot;chars&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>从<code>PDF</code>字符构建文本内容</strong></p>
<ol>
<li>遍历所有OCR文本框</li>
<li>如果文本框没有关联的<code>PDF</code>字符，删除<code>chars</code>键（这种情况可能出现在扫描版<code>PDF</code>中，或者OCR检测框与<code>PDF</code>字符没有重叠）</li>
<li>计算关联字符的平均高度</li>
<li>使用<code>Recognizer.sort_Y_firstly</code>按Y轴排序字符</li>
<li>遍历排序后的字符：<ul>
<li>如果字符是空格且文本框已有文本内容，检查是否需要添加空格</li>
<li>否则直接将字符文本添加到文本框文本中</li>
</ul>
</li>
<li>删除<code>chars</code>键</li>
</ol>
<blockquote>
<p>简单来讲，这一步就是使用上一步添加的chars键中的内容进行text键的内容的构建，使用后删除chars键。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logging.info(<span class="string">f&quot;__ocr sorting <span class="subst">&#123;<span class="built_in">len</span>(chars)&#125;</span> chars cost <span class="subst">&#123;timer() - start&#125;</span>s&quot;</span>)</span><br><span class="line">start = timer()</span><br><span class="line">boxes_to_reg = []</span><br><span class="line">img_np = np.array(img)</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> bxs:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b[<span class="string">&quot;text&quot;</span>]:</span><br><span class="line">        left, right, top, bott = b[<span class="string">&quot;x0&quot;</span>] * ZM, b[<span class="string">&quot;x1&quot;</span>] * \</span><br><span class="line">                                 ZM, b[<span class="string">&quot;top&quot;</span>] * ZM, b[<span class="string">&quot;bottom&quot;</span>] * ZM</span><br><span class="line">        b[<span class="string">&quot;box_image&quot;</span>] = <span class="variable language_">self</span>.ocr.get_rotate_crop_image(img_np, np.array([[left, top], [right, top], [right, bott], [left, bott]], dtype=np.float32))</span><br><span class="line">        boxes_to_reg.append(b)</span><br><span class="line">    <span class="keyword">del</span> b[<span class="string">&quot;txt&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>准备需要进一步识别的文本框</strong></p>
<ol>
<li>记录并记录字符排序耗时</li>
<li>初始化需要识别的文本框列<code>boxes_to_reg</code></li>
<li>将<code>PIL</code>图像转换为<code>numpy</code>数组</li>
<li>遍历所有文本框：<ul>
<li>如果文本框没有文本内容：<ul>
<li>计算放大后的边界坐标（乘以缩放因子<code>ZM</code>）</li>
<li>使用<code>get_rotate_crop_image</code>方法裁剪出文本框图像</li>
<li>将文本框添加到<code>boxes_to_reg</code>列表</li>
</ul>
</li>
<li>删除<code>txt</code>键</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">texts = <span class="variable language_">self</span>.ocr.recognize_batch([b[<span class="string">&quot;box_image&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> boxes_to_reg], device_id)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(boxes_to_reg)):</span><br><span class="line">    boxes_to_reg[i][<span class="string">&quot;text&quot;</span>] = texts[i]</span><br><span class="line">    <span class="keyword">del</span> boxes_to_reg[i][<span class="string">&quot;box_image&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>批量文本识别</strong></p>
<ol>
<li>提取所有需要识别的文本框图像</li>
<li>使用<code>self.ocr.recognize_batch</code>方法批量识别文本</li>
<li>将识别结果更新到对应文本框中</li>
<li>删除<code>box_image</code>键</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logging.info(<span class="string">f&quot;__ocr recognize <span class="subst">&#123;<span class="built_in">len</span>(bxs)&#125;</span> boxes cost <span class="subst">&#123;timer() - start&#125;</span>s&quot;</span>)</span><br><span class="line">bxs = [b <span class="keyword">for</span> b <span class="keyword">in</span> bxs <span class="keyword">if</span> b[<span class="string">&quot;text&quot;</span>]]</span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.mean_height[pagenum-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">    <span class="variable language_">self</span>.mean_height[pagenum-<span class="number">1</span>] = np.median([b[<span class="string">&quot;bottom&quot;</span>] - b[<span class="string">&quot;top&quot;</span>]</span><br><span class="line">                                      <span class="keyword">for</span> b <span class="keyword">in</span> bxs])</span><br><span class="line"><span class="variable language_">self</span>.boxes.append(bxs)</span><br></pre></td></tr></table></figure>

<p><strong>最终处理和保存结果</strong></p>
<ol>
<li>记录并记录识别耗时</li>
<li>过滤掉没有文本内容的文本框</li>
<li>如果当前页的平均高度为0，计算并更新平均高度</li>
<li>将处理后的文本框列表添加到<code>self.boxes</code></li>
</ol>
<p><strong>整体流程总结</strong></p>
<p>这个<code>__ocr</code>方法实现了完整的OCR处理流程：</p>
<ol>
<li><strong>文本检测</strong>：使用OCR检测器找出图像中的文本区域</li>
<li><strong>数据整合</strong>：将PDF提取的字符信息与OCR检测结果合并</li>
<li><strong>文本构建</strong>：利用<code>PDF</code>字符信息构建初步文本内容</li>
<li><strong>补充识别</strong>：对没有文本内容的区域进行更精确的OCR识别</li>
<li><strong>结果保存</strong>：将处理结果保存到<code>self.boxes</code>中</li>
</ol>
<p><strong>普通PDF与扫描件PDF处理差异</strong>：</p>
<ul>
<li><strong>普通<code>PDF</code></strong>：能够从<code>PDF</code>中提取到字符信息(<code>self.page_chars</code>)，这些信息用于与OCR检测结果融合，提高识别准确性</li>
<li><strong>扫描件<code>PDF</code></strong>：无法从<code>PDF</code>中提取字符信息，主要依赖OCR进行文本识别，处理结果完全基于图像识别</li>
</ul>
<p><strong>中英文PDF处理差异</strong>：</p>
<ul>
<li><strong>英文<code>PDF</code></strong>：在OCR预处理阶段更多依赖OCR识别结果，即使能提取到<code>PDF</code>字符也主要使用OCR</li>
<li><strong>非英文<code>PDF</code></strong>（如中文）：更多利用从<code>PDF</code>中提取的字符信息来构建文本内容，因为对中文等复杂文字，直接提取通常比OCR更准确</li>
</ul>
<p>这种方法结合了<code>PDF</code>直接提取的字符信息和OCR识别结果，能够提供更准确和完整的文本识别效果。</p>
<hr>
<h3 id="self-layouts-rec-…"><a href="#self-layouts-rec-…" class="headerlink" title="self._layouts_rec(…)"></a>self._layouts_rec(…)</h3><p><code>_layouts_rec</code>方法是<code>RAGFlow</code> 的<code>PDF</code>解析流程中的布局识别阶段，负责识别和分析文档的布局结构。</p>
<p><strong>方法签名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_layouts_rec</span>(<span class="params">self, ZM, drop=<span class="literal">True</span></span>):</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>ZM</code>：缩放因子，用于坐标转换</li>
<li><code>drop</code>：是否丢弃某些布局元素的标志，默认为True</li>
</ul>
<p><strong>布局识别调用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.boxes, <span class="variable language_">self</span>.page_layout = <span class="variable language_">self</span>.layouter(</span><br><span class="line">    <span class="variable language_">self</span>.page_images, <span class="variable language_">self</span>.boxes, ZM, drop=drop)</span><br></pre></td></tr></table></figure>

<p>这行代码调用了布局识别器<code>self.layouter</code>来分析文档布局：</p>
<ul>
<li>输入参数：<ul>
<li><code>self.page_images</code>：页面图像列表</li>
<li><code>self.boxes</code>：OCR识别出的文本框列表</li>
<li><code>ZM</code>：缩放因子</li>
<li><code>drop</code>：是否丢弃某些元素</li>
</ul>
</li>
<li>输出结果：<ul>
<li>更新后的<code>self.boxes</code>：添加了布局类型信息的文本框</li>
<li><code>self.page_layout</code>：每页的布局元素信息</li>
</ul>
</li>
</ul>
<p><strong>坐标系统调整</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cumlative Y</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.boxes)):</span><br><span class="line">    <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;top&quot;</span>] += \</span><br><span class="line">        <span class="variable language_">self</span>.page_cum_height[<span class="variable language_">self</span>.boxes[i][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>]</span><br><span class="line">    <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;bottom&quot;</span>] += \</span><br><span class="line">        <span class="variable language_">self</span>.page_cum_height[<span class="variable language_">self</span>.boxes[i][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>这部分代码将文本框的Y坐标从页面相对坐标转换为文档绝对坐标：</p>
<ul>
<li>使用<code>self.page_cum_height</code>数组中存储的每页累积高度</li>
<li>将每个文本框的<code>top</code>和<code>bottom</code>坐标加上对应页面的累积高度</li>
<li>实现跨页文本框的统一坐标系统</li>
</ul>
<p><strong>布局识别器功能</strong></p>
<p>布局识别器（<code>LayoutRecognizer</code>）主要识别以下类型的布局元素：</p>
<ol>
<li><strong>文本区域</strong>（text）：普通文本段落</li>
<li><strong>标题</strong>（title）：文档标题</li>
<li><strong>表格</strong>（table）：表格区域</li>
<li><strong>图表</strong>（figure）：图像和图表</li>
<li><strong>表格标题</strong>（table caption）：表格说明文字</li>
<li><strong>图表标题</strong>（figure caption）：图表说明文字</li>
<li><strong>公式</strong>（equation）：数学公式</li>
<li><strong>参考文献</strong>（reference）：参考文献列表</li>
</ol>
<p><strong>数据结构变化</strong></p>
<p><strong>处理前的文本框结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: <span class="number">300.0</span>,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: <span class="number">50.0</span>,</span><br><span class="line">        <span class="string">&quot;bottom&quot;</span>: <span class="number">70.0</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Some text content&quot;</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>处理后的文本框结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">        <span class="string">&quot;x1&quot;</span>: <span class="number">300.0</span>,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: <span class="number">150.0</span>,      <span class="comment"># 已加上累积高度</span></span><br><span class="line">        <span class="string">&quot;bottom&quot;</span>: <span class="number">170.0</span>,   <span class="comment"># 已加上累积高度</span></span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Some text content&quot;</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>,  <span class="comment"># 新增：布局类型</span></span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span>,          <span class="comment"># 新增：布局编号</span></span><br><span class="line">        <span class="string">&quot;score&quot;</span>: <span class="number">0.95</span>           <span class="comment"># 新增：识别置信度</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>页面布局结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.page_layout = [</span><br><span class="line">    [  <span class="comment"># 第1页的布局元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;x0&quot;</span>: <span class="number">90.0</span>,</span><br><span class="line">            <span class="string">&quot;x1&quot;</span>: <span class="number">310.0</span>,</span><br><span class="line">            <span class="string">&quot;top&quot;</span>: <span class="number">40.0</span>,</span><br><span class="line">            <span class="string">&quot;bottom&quot;</span>: <span class="number">80.0</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,      <span class="comment"># 布局类型</span></span><br><span class="line">            <span class="string">&quot;score&quot;</span>: <span class="number">0.98</span>        <span class="comment"># 置信度</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">            <span class="string">&quot;x1&quot;</span>: <span class="number">300.0</span>,</span><br><span class="line">            <span class="string">&quot;top&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">            <span class="string">&quot;bottom&quot;</span>: <span class="number">200.0</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;figure&quot;</span>,</span><br><span class="line">            <span class="string">&quot;score&quot;</span>: <span class="number">0.92</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    [  <span class="comment"># 第2页的布局元素</span></span><br><span class="line">        // ...</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>在整个<code>PDF</code>解析流程中的作用</strong></p>
<ol>
<li><strong>文档结构理解</strong>：<ul>
<li>识别文档中的不同元素类型</li>
<li>为后续处理提供结构化信息</li>
</ul>
</li>
<li><strong>坐标系统统一</strong>：<ul>
<li>将页面相对坐标转换为文档绝对坐标</li>
<li>支持跨页文本处理</li>
</ul>
</li>
<li><strong>语义信息增强</strong>：<ul>
<li>为文本框添加布局类型信息</li>
<li>支持不同类型内容的差异化处理</li>
</ul>
</li>
<li><strong>后续处理基础</strong>：<ul>
<li>为表格识别、文本合并等步骤提供布局信息</li>
<li>支持更智能的文档分析</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>实际应用场景</strong></p>
<p>布局识别器具体可查看<code>deepdoc/vision/layout_recognizer.py</code>中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayoutRecognizer</span>(<span class="title class_ inherited__">Recognizer</span>):</span><br><span class="line">    labels = [</span><br><span class="line">        <span class="string">&quot;_background_&quot;</span>,	<span class="comment"># 背景</span></span><br><span class="line">        <span class="string">&quot;Text&quot;</span>,			<span class="comment"># 普通文本</span></span><br><span class="line">        <span class="string">&quot;Title&quot;</span>,		<span class="comment"># 标题</span></span><br><span class="line">        <span class="string">&quot;Figure&quot;</span>,		<span class="comment"># 图像/图表</span></span><br><span class="line">        <span class="string">&quot;Figure caption&quot;</span>,	<span class="comment"># 图像标题</span></span><br><span class="line">        <span class="string">&quot;Table&quot;</span>,			<span class="comment"># 表格</span></span><br><span class="line">        <span class="string">&quot;Table caption&quot;</span>,	<span class="comment"># 表格标题</span></span><br><span class="line">        <span class="string">&quot;Header&quot;</span>,			<span class="comment"># 页眉</span></span><br><span class="line">        <span class="string">&quot;Footer&quot;</span>,			<span class="comment"># 页脚</span></span><br><span class="line">        <span class="string">&quot;Reference&quot;</span>,		<span class="comment"># 参考文献</span></span><br><span class="line">        <span class="string">&quot;Equation&quot;</span>,			<span class="comment"># 数字公式</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>.garbage_layouts = [<span class="string">&quot;footer&quot;</span>, <span class="string">&quot;header&quot;</span>, <span class="string">&quot;reference&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>假设一个两页的<code>PDF</code>文档：</p>
<p>第一步：处理前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1页文本框</span></span><br><span class="line">page1_boxes = [</span><br><span class="line">    &#123;<span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">300</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">120</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;First paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">250</span>, <span class="string">&quot;top&quot;</span>: <span class="number">150</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">170</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Second paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2页文本框</span></span><br><span class="line">page2_boxes = [</span><br><span class="line">    &#123;<span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">300</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">120</span>, <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Third paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.boxes = [page1_boxes, page2_boxes]</span><br><span class="line"><span class="variable language_">self</span>.page_cum_height = [<span class="number">0</span>, <span class="number">200</span>]  <span class="comment"># 第1页高度200</span></span><br></pre></td></tr></table></figure>

<p>第二步：布局识别后</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新的文本框（添加布局信息）</span></span><br><span class="line"><span class="variable language_">self</span>.boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">300</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">120</span>, </span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;First paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">250</span>, <span class="string">&quot;top&quot;</span>: <span class="number">150</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">170</span>, </span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Second paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;layoutno&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">300</span>, <span class="string">&quot;top&quot;</span>: <span class="number">300</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">320</span>,  <span class="comment"># 坐标已调整（100+200）</span></span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Third paragraph&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 页面布局信息</span></span><br><span class="line"><span class="variable language_">self</span>.page_layout = [</span><br><span class="line">    [  <span class="comment"># 第1页布局</span></span><br><span class="line">        &#123;<span class="string">&quot;x0&quot;</span>: <span class="number">70</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">310</span>, <span class="string">&quot;top&quot;</span>: <span class="number">90</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">180</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">0.95</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    [  <span class="comment"># 第2页布局</span></span><br><span class="line">        &#123;<span class="string">&quot;x0&quot;</span>: <span class="number">70</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">310</span>, <span class="string">&quot;top&quot;</span>: <span class="number">90</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">130</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">0.95</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p>这个方法是<code>RAGFlow</code>文档解析流程中的关键步骤，通过识别文档布局结构并统一坐标系统，为后续的表格识别、文本合并、内容提取等步骤提供了重要的结构化信息基础。</p>
<hr>
<h3 id="self-table-transformer-job-…"><a href="#self-table-transformer-job-…" class="headerlink" title="self._table_transformer_job(…)"></a>self._table_transformer_job(…)</h3><p><code>_table_transformer_job</code>方法是<code>RAGFlow</code>的<code>PDF</code>解析流程中的表格处理阶段，负责对检测到的表格进行精细的结构分析。</p>
<p><strong>方法功能概述</strong></p>
<p>该方法的主要作用是：</p>
<ol>
<li><strong>提取表格图像</strong>：从页面图像中裁剪出检测到的表格区域</li>
<li><strong>表格结构识别</strong>：使用专用的表格结构识别器识别表格内部结构</li>
<li><strong>坐标系统转换</strong>：将识别结果转换为文档统一坐标系统</li>
<li><strong>表格元素标记</strong>：为文本框添加表格相关的行列信息</li>
</ol>
<p><strong>详细实现流程</strong></p>
<p><strong>表格图像提取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p, tbls <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.page_layout):  <span class="comment"># for page</span></span><br><span class="line">    tbls = [f <span class="keyword">for</span> f <span class="keyword">in</span> tbls <span class="keyword">if</span> f[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;table&quot;</span>]</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> tbls:  <span class="comment"># for table</span></span><br><span class="line">        left, top, right, bott = tb[<span class="string">&quot;x0&quot;</span>] - MARGIN, tb[<span class="string">&quot;top&quot;</span>] - MARGIN, \</span><br><span class="line">            tb[<span class="string">&quot;x1&quot;</span>] + MARGIN, tb[<span class="string">&quot;bottom&quot;</span>] + MARGIN</span><br><span class="line">        left *= ZM</span><br><span class="line">        top *= ZM</span><br><span class="line">        right *= ZM</span><br><span class="line">        bott *= ZM</span><br><span class="line">        pos.append((left, top))</span><br><span class="line">        imgs.append(<span class="variable language_">self</span>.page_images[p].crop((left, top, right, bott)))</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历每页的布局元素，筛选出类型为<code>table</code>的元素</li>
<li>为每个表格添加边距(MARGIN&#x3D;10)</li>
<li>将坐标从<code>PDF</code>坐标转换为图像坐标(<code>ZM</code>缩放因子)</li>
<li>裁剪出表格图像并保存</li>
</ul>
<p><strong>表格结构识别</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recos = <span class="variable language_">self</span>.tbl_det(imgs)</span><br></pre></td></tr></table></figure>

<p>使用<code>TableStructureRecognizer</code>对裁剪出的表格图像进行结构识别，可识别的元素包括：</p>
<ul>
<li><code>table</code> - 表格整体</li>
<li><code>table column</code> - 表格列</li>
<li><code>table row</code> - 表格行</li>
<li><code>table column header</code> - 表格列标题</li>
<li><code>table projected row header</code> - 表格行标题</li>
<li><code>table spanning cell</code> - 跨行列的单元格</li>
</ul>
<p><strong>坐标系统转换和数据整理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tbcnt) - <span class="number">1</span>):  <span class="comment"># for page</span></span><br><span class="line">    pg = []</span><br><span class="line">    <span class="keyword">for</span> j, tb_items <span class="keyword">in</span> <span class="built_in">enumerate</span>(</span><br><span class="line">            recos[tbcnt[i]: tbcnt[i + <span class="number">1</span>]]):  <span class="comment"># for table</span></span><br><span class="line">        poss = pos[tbcnt[i]: tbcnt[i + <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> tb_items:  <span class="comment"># for table components</span></span><br><span class="line">            it[<span class="string">&quot;x0&quot;</span>] = (it[<span class="string">&quot;x0&quot;</span>] + poss[j][<span class="number">0</span>])</span><br><span class="line">            it[<span class="string">&quot;x1&quot;</span>] = (it[<span class="string">&quot;x1&quot;</span>] + poss[j][<span class="number">0</span>])</span><br><span class="line">            it[<span class="string">&quot;top&quot;</span>] = (it[<span class="string">&quot;top&quot;</span>] + poss[j][<span class="number">1</span>])</span><br><span class="line">            it[<span class="string">&quot;bottom&quot;</span>] = (it[<span class="string">&quot;bottom&quot;</span>] + poss[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="string">&quot;x0&quot;</span>, <span class="string">&quot;x1&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;bottom&quot;</span>]:</span><br><span class="line">                it[n] /= ZM</span><br><span class="line">            it[<span class="string">&quot;top&quot;</span>] += <span class="variable language_">self</span>.page_cum_height[i]</span><br><span class="line">            it[<span class="string">&quot;bottom&quot;</span>] += <span class="variable language_">self</span>.page_cum_height[i]</span><br><span class="line">            it[<span class="string">&quot;pn&quot;</span>] = i</span><br><span class="line">            it[<span class="string">&quot;layoutno&quot;</span>] = j</span><br><span class="line">            pg.append(it)</span><br><span class="line">    <span class="variable language_">self</span>.tb_cpns.extend(pg)</span><br></pre></td></tr></table></figure>

<ul>
<li>将识别结果从图像坐标转换回<code>PDF</code>坐标</li>
<li>添加页面累积高度，实现文档统一坐标系统</li>
<li>添加页面编号和布局编号信息</li>
</ul>
<p><strong>表格元素分类和清理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gather</span>(<span class="params">kwd, fzy=<span class="number">10</span>, ption=<span class="number">0.6</span></span>):</span><br><span class="line">    eles = Recognizer.sort_Y_firstly(</span><br><span class="line">        [r <span class="keyword">for</span> r <span class="keyword">in</span> <span class="variable language_">self</span>.tb_cpns <span class="keyword">if</span> re.<span class="keyword">match</span>(kwd, r[<span class="string">&quot;label&quot;</span>])], fzy)</span><br><span class="line">    eles = Recognizer.layouts_cleanup(<span class="variable language_">self</span>.boxes, eles, <span class="number">5</span>, ption)</span><br><span class="line">    <span class="keyword">return</span> Recognizer.sort_Y_firstly(eles, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">headers = gather(<span class="string">r&quot;.*header$&quot;</span>)</span><br><span class="line">rows = gather(<span class="string">r&quot;.* (row|header)&quot;</span>)</span><br><span class="line">spans = gather(<span class="string">r&quot;.*spanning&quot;</span>)</span><br><span class="line">clmns = <span class="built_in">sorted</span>([r <span class="keyword">for</span> r <span class="keyword">in</span> <span class="variable language_">self</span>.tb_cpns <span class="keyword">if</span> re.<span class="keyword">match</span>(</span><br><span class="line">    <span class="string">r&quot;table column$&quot;</span>, r[<span class="string">&quot;label&quot;</span>])], key=<span class="keyword">lambda</span> x: (x[<span class="string">&quot;pn&quot;</span>], x[<span class="string">&quot;layoutno&quot;</span>], x[<span class="string">&quot;x0&quot;</span>]))</span><br><span class="line">clmns = Recognizer.layouts_cleanup(<span class="variable language_">self</span>.boxes, clmns, <span class="number">5</span>, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>分类提取不同类型的表格元素：表头、行、跨行列单元格、列</li>
<li>使用正则表达式匹配标签类型</li>
<li>清理和排序元素</li>
</ul>
<p><strong>为文本框添加表格信息</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes:</span><br><span class="line">    <span class="keyword">if</span> b.get(<span class="string">&quot;layout_type&quot;</span>, <span class="string">&quot;&quot;</span>) != <span class="string">&quot;table&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ii = Recognizer.find_overlapped_with_threshold(b, rows, thr=<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        b[<span class="string">&quot;R&quot;</span>] = ii</span><br><span class="line">        b[<span class="string">&quot;R_top&quot;</span>] = rows[ii][<span class="string">&quot;top&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;R_bott&quot;</span>] = rows[ii][<span class="string">&quot;bottom&quot;</span>]</span><br><span class="line"></span><br><span class="line">    ii = Recognizer.find_overlapped_with_threshold(</span><br><span class="line">        b, headers, thr=<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        b[<span class="string">&quot;H_top&quot;</span>] = headers[ii][<span class="string">&quot;top&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_bott&quot;</span>] = headers[ii][<span class="string">&quot;bottom&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_left&quot;</span>] = headers[ii][<span class="string">&quot;x0&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_right&quot;</span>] = headers[ii][<span class="string">&quot;x1&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H&quot;</span>] = ii</span><br><span class="line"></span><br><span class="line">    ii = Recognizer.find_horizontally_tightest_fit(b, clmns)</span><br><span class="line">    <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        b[<span class="string">&quot;C&quot;</span>] = ii</span><br><span class="line">        b[<span class="string">&quot;C_left&quot;</span>] = clmns[ii][<span class="string">&quot;x0&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;C_right&quot;</span>] = clmns[ii][<span class="string">&quot;x1&quot;</span>]</span><br><span class="line"></span><br><span class="line">    ii = Recognizer.find_overlapped_with_threshold(b, spans, thr=<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        b[<span class="string">&quot;H_top&quot;</span>] = spans[ii][<span class="string">&quot;top&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_bott&quot;</span>] = spans[ii][<span class="string">&quot;bottom&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_left&quot;</span>] = spans[ii][<span class="string">&quot;x0&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;H_right&quot;</span>] = spans[ii][<span class="string">&quot;x1&quot;</span>]</span><br><span class="line">        b[<span class="string">&quot;SP&quot;</span>] = ii</span><br></pre></td></tr></table></figure>

<p>为布局类型为<code>table</code>的文本框添加以下信息：</p>
<ul>
<li><code>R</code> - 行号及相关信息</li>
<li><code>H</code> - 表头信息</li>
<li><code>C</code> - 列号及相关信息</li>
<li><code>SP</code> - 跨行列信息</li>
</ul>
<p><strong>输出结果</strong></p>
<p>方法执行后，会在文本框中添加以下表格相关字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;x0&quot;</span>: <span class="number">100.0</span>,</span><br><span class="line">    <span class="string">&quot;x1&quot;</span>: <span class="number">200.0</span>,</span><br><span class="line">    <span class="string">&quot;top&quot;</span>: <span class="number">150.0</span>,</span><br><span class="line">    <span class="string">&quot;bottom&quot;</span>: <span class="number">170.0</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Cell content&quot;</span>,</span><br><span class="line">    <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;table&quot;</span>,</span><br><span class="line">    <span class="string">&quot;R&quot;</span>: <span class="number">2</span>,           <span class="comment"># 行号</span></span><br><span class="line">    <span class="string">&quot;R_top&quot;</span>: <span class="number">140.0</span>,   <span class="comment"># 行顶部坐标</span></span><br><span class="line">    <span class="string">&quot;R_bott&quot;</span>: <span class="number">180.0</span>,  <span class="comment"># 行底部坐标</span></span><br><span class="line">    <span class="string">&quot;C&quot;</span>: <span class="number">1</span>,           <span class="comment"># 列号</span></span><br><span class="line">    <span class="string">&quot;C_left&quot;</span>: <span class="number">150.0</span>,  <span class="comment"># 列左边界</span></span><br><span class="line">    <span class="string">&quot;C_right&quot;</span>: <span class="number">250.0</span>, <span class="comment"># 列右边界</span></span><br><span class="line">    <span class="string">&quot;H&quot;</span>: <span class="number">0</span>,           <span class="comment"># 表头标识</span></span><br><span class="line">    <span class="string">&quot;SP&quot;</span>: <span class="number">1</span>           <span class="comment"># 跨行列标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在整个<code>PDF</code>解析流程中的作用</strong></p>
<ol>
<li><strong>表格结构理解</strong>：识别表格内部的行列结构</li>
<li><strong>跨页表格处理</strong>：支持跨页表格的统一处理</li>
<li><strong>数据提取准备</strong>：为后续表格数据提取提供结构信息</li>
<li><strong>内容组织</strong>：帮助正确组织表格内容</li>
</ol>
<p>这是<code>RAGFlow</code>文档解析流程中非常重要的一步，特别是对于包含大量表格数据的文档，通过精细的表格结构识别，可以大大提高表格内容提取的准确性和完整性。</p>
<hr>
<h3 id="self-text-merge"><a href="#self-text-merge" class="headerlink" title="self._text_merge()"></a>self._text_merge()</h3><p><code>_text_merge</code>方法是<code>RAGFlow</code> 的<code>PDF</code>解析流程中的文本合并阶段，负责将相邻且相关的文本框合并成更大的文本块。</p>
<p><strong>方法功能概述</strong></p>
<p>该方法的主要作用是：</p>
<ol>
<li><strong>横向合并</strong>：将同一行中相邻的文本框合并</li>
<li><strong>布局保持</strong>：保持相同布局的文本框合并</li>
<li><strong>语义连贯</strong>：确保合并后的文本在语义上是连贯的</li>
</ol>
<p><strong>详细实现分析</strong></p>
<p><strong>辅助函数定义</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">end_with</span>(<span class="params">b, txt</span>):</span><br><span class="line">    txt = txt.strip()</span><br><span class="line">    tt = b.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> tt <span class="keyword">and</span> tt.find(txt) == <span class="built_in">len</span>(tt) - <span class="built_in">len</span>(txt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_with</span>(<span class="params">b, txts</span>):</span><br><span class="line">    tt = b.get(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> tt <span class="keyword">and</span> <span class="built_in">any</span>([tt.find(t.strip()) == <span class="number">0</span> <span class="keyword">for</span> t <span class="keyword">in</span> txts])</span><br></pre></td></tr></table></figure>

<p>这两个辅助函数用于检查文本框的文本是否以特定字符结尾或开头：</p>
<ul>
<li><code>end_with</code>：检查文本框是否以指定文本结尾</li>
<li><code>start_with</code>：检查文本框是否以指定文本列表中的任意一个开头</li>
</ul>
<p><strong>主要合并逻辑</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># horizontally merge adjacent box with the same layout</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(bxs) - <span class="number">1</span>:</span><br><span class="line">    b = bxs[i]</span><br><span class="line">    b_ = bxs[i + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>遍历所有相邻的文本框对，进行合并判断。</p>
<p><strong>合并条件检查</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> b.get(<span class="string">&quot;layoutno&quot;</span>, <span class="string">&quot;0&quot;</span>) != b_.get(<span class="string">&quot;layoutno&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="keyword">or</span> b.get(<span class="string">&quot;layout_type&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">in</span> [<span class="string">&quot;table&quot;</span>, <span class="string">&quot;figure&quot;</span>, <span class="string">&quot;equation&quot;</span>]:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>跳过不满足合并条件的文本框对：</p>
<ul>
<li>不同布局编号的文本框不合并</li>
<li>表格、图像、公式类型的文本框不合并</li>
</ul>
<p><strong>垂直距离检查</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(<span class="variable language_">self</span>._y_dis(b, b_)) &lt; <span class="variable language_">self</span>.mean_height[bxs[i][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>] / <span class="number">3</span>:</span><br><span class="line">    <span class="comment"># merge</span></span><br><span class="line">    bxs[i][<span class="string">&quot;x1&quot;</span>] = b_[<span class="string">&quot;x1&quot;</span>]</span><br><span class="line">    bxs[i][<span class="string">&quot;top&quot;</span>] = (b[<span class="string">&quot;top&quot;</span>] + b_[<span class="string">&quot;top&quot;</span>]) / <span class="number">2</span></span><br><span class="line">    bxs[i][<span class="string">&quot;bottom&quot;</span>] = (b[<span class="string">&quot;bottom&quot;</span>] + b_[<span class="string">&quot;bottom&quot;</span>]) / <span class="number">2</span></span><br><span class="line">    bxs[i][<span class="string">&quot;text&quot;</span>] += b_[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    bxs.pop(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>如果两个文本框在垂直方向上的距离小于页面平均字符高度的1&#x2F;3，则进行合并：</p>
<ul>
<li>更新合并后文本框的右边界、上下边界</li>
<li>将两个文本框的文本内容连接</li>
<li>删除被合并的文本框</li>
</ul>
<p><strong>特殊情况处理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dis_thr = <span class="number">1</span></span><br><span class="line">dis = b[<span class="string">&quot;x1&quot;</span>] - b_[<span class="string">&quot;x0&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> b.get(<span class="string">&quot;layout_type&quot;</span>, <span class="string">&quot;&quot;</span>) != <span class="string">&quot;text&quot;</span> <span class="keyword">or</span> b_.get(<span class="string">&quot;layout_type&quot;</span>, <span class="string">&quot;&quot;</span>) != <span class="string">&quot;text&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> end_with(b, <span class="string">&quot;，&quot;</span>) <span class="keyword">or</span> start_with(b_, <span class="string">&quot;（，&quot;</span>):</span><br><span class="line">        dis_thr = -<span class="number">8</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(<span class="variable language_">self</span>._y_dis(b, b_)) &lt; <span class="variable language_">self</span>.mean_height[bxs[i][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>] / <span class="number">5</span> \</span><br><span class="line">        <span class="keyword">and</span> dis &gt;= dis_thr <span class="keyword">and</span> b[<span class="string">&quot;x1&quot;</span>] &lt; b_[<span class="string">&quot;x1&quot;</span>]:</span><br><span class="line">    <span class="comment"># merge</span></span><br><span class="line">    bxs[i][<span class="string">&quot;x1&quot;</span>] = b_[<span class="string">&quot;x1&quot;</span>]</span><br><span class="line">    bxs[i][<span class="string">&quot;top&quot;</span>] = (b[<span class="string">&quot;top&quot;</span>] + b_[<span class="string">&quot;top&quot;</span>]) / <span class="number">2</span></span><br><span class="line">    bxs[i][<span class="string">&quot;bottom&quot;</span>] = (b[<span class="string">&quot;bottom&quot;</span>] + b_[<span class="string">&quot;bottom&quot;</span>]) / <span class="number">2</span></span><br><span class="line">    bxs[i][<span class="string">&quot;text&quot;</span>] += b_[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    bxs.pop(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>处理非文本类型布局的特殊情况：</p>
<ul>
<li>对于以”，”结尾或以”（，”开头的文本，允许负间距合并</li>
<li>使用更严格的垂直距离阈值（1&#x2F;5平均字符高度）</li>
<li>检查水平间距是否满足阈值要求</li>
</ul>
<blockquote>
<p><strong>合并过程示例</strong></p>
<p>假设有以下文本框序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bxs = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">150</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">120</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is the first part&quot;</span>,</span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">155</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">250</span>, <span class="string">&quot;top&quot;</span>: <span class="number">101</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">119</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;of a sentence.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">200</span>, <span class="string">&quot;top&quot;</span>: <span class="number">130</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is another sentence.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>经过<code>_text_merge</code>处理后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bxs = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">250</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100.5</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">119.5</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is the first partof a sentence.&quot;</span>,  <span class="comment"># 注意：这里可能缺少空格</span></span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">0</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">200</span>, <span class="string">&quot;top&quot;</span>: <span class="number">130</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is another sentence.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;layoutno&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>在整个<code>PDF</code>解析流程中的作用</strong></p>
<ol>
<li><strong>文本连贯性</strong>：将逻辑上属于同一段落的文本片段合并</li>
<li><strong>减少冗余</strong>：减少文本框数量，简化后续处理</li>
<li><strong>结构优化</strong>：优化文本结构，提高处理效率</li>
<li><strong>语义保持</strong>：在合并过程中保持文本的语义完整性</li>
</ol>
<p><strong>设计考虑</strong></p>
<ol>
<li><strong>布局一致性</strong>：只合并相同布局编号的文本框</li>
<li><strong>距离阈值</strong>：使用平均字符高度作为距离判断标准</li>
<li><strong>类型区分</strong>：对不同类型的布局采用不同的处理策略</li>
<li><strong>特殊字符处理</strong>：考虑中文标点符号的特殊合并需求</li>
</ol>
<p>这个方法是<code>RAGFlow</code>文档解析流程中的重要优化步骤，通过智能地合并相邻文本框，提高了文本内容的连贯性和处理效率。</p>
<hr>
<h3 id="self-extract-table-figure-…"><a href="#self-extract-table-figure-…" class="headerlink" title="self._extract_table_figure(…)"></a>self._extract_table_figure(…)</h3><p><code>_extract_table_figure</code>方法是<code>RAGFlow</code>的<code>PDF</code>解析流程中负责<strong>提取表格和图像内容</strong>的核心方法。</p>
<p><strong>方法签名分析</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_extract_table_figure</span>(<span class="params">self, need_image, ZM, return_html, need_position, separate_tables_figures=<span class="literal">False</span></span>):</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>need_image</code>：是否需要提取图像</li>
<li><code>ZM</code>：缩放因子</li>
<li><code>return_html</code>：是否返回HTML格式的表格</li>
<li><code>need_position</code>：是否需要位置信息</li>
<li><code>separate_tables_figures</code>：是否分离返回表格和图像</li>
</ul>
<p><strong>详细实现流程</strong></p>
<p><strong>初始化数据结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tables = &#123;&#125;</span><br><span class="line">figures = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>初始化两个字典用于存储表格和图像：</p>
<ul>
<li><code>tables</code>：存储表格内容，键为”页码-layoutno”格式的字符串</li>
<li><code>figures</code>：存储图像内容，键为”页码-layoutno”格式的字符串</li>
</ul>
<p><strong>提取表格和图像框</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># extract figure and table boxes</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">lst_lout_no = <span class="string">&quot;&quot;</span></span><br><span class="line">nomerge_lout_no = []</span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.boxes):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;layoutno&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.boxes[i]:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    lout_no = <span class="built_in">str</span>(<span class="variable language_">self</span>.boxes[i][<span class="string">&quot;page_number&quot;</span>]) + \</span><br><span class="line">        <span class="string">&quot;-&quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.boxes[i][<span class="string">&quot;layoutno&quot;</span>])</span><br><span class="line">    <span class="keyword">if</span> TableStructureRecognizer.is_caption(<span class="variable language_">self</span>.boxes[i]) <span class="keyword">or</span> <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;layout_type&quot;</span>] <span class="keyword">in</span> [<span class="string">&quot;table caption&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;figure caption&quot;</span>, <span class="string">&quot;reference&quot;</span>]:</span><br><span class="line">        nomerge_lout_no.append(lst_lout_no)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;table&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&quot;(数据|资料|图表)*来源[:： ]&quot;</span>, <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;text&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.boxes.pop(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> lout_no <span class="keyword">not</span> <span class="keyword">in</span> tables:</span><br><span class="line">            tables[lout_no] = []</span><br><span class="line">        tables[lout_no].append(<span class="variable language_">self</span>.boxes[i])</span><br><span class="line">        <span class="variable language_">self</span>.boxes.pop(i)</span><br><span class="line">        lst_lout_no = lout_no</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> need_image <span class="keyword">and</span> <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;figure&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&quot;(数据|资料|图表)*来源[:： ]&quot;</span>, <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;text&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.boxes.pop(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> lout_no <span class="keyword">not</span> <span class="keyword">in</span> figures:</span><br><span class="line">            figures[lout_no] = []</span><br><span class="line">        figures[lout_no].append(<span class="variable language_">self</span>.boxes[i])</span><br><span class="line">        <span class="variable language_">self</span>.boxes.pop(i)</span><br><span class="line">        lst_lout_no = lout_no</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个循环的主要作用是：</p>
<ol>
<li>遍历所有文本框</li>
<li>识别并提取表格和图像相关的文本框</li>
<li>过滤掉”数据来源”等无关内容</li>
<li>将表格和图像文本框从<code>self.boxes</code>中移除</li>
</ol>
<p><strong>跨页表格合并</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># merge table on different pages</span></span><br><span class="line">nomerge_lout_no = <span class="built_in">set</span>(nomerge_lout_no)</span><br><span class="line">tbls = <span class="built_in">sorted</span>([(k, bxs) <span class="keyword">for</span> k, bxs <span class="keyword">in</span> tables.items()],</span><br><span class="line">              key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&quot;top&quot;</span>], x[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&quot;x0&quot;</span>]))</span><br><span class="line"></span><br><span class="line">i = <span class="built_in">len</span>(tbls) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">    k0, bxs0 = tbls[i - <span class="number">1</span>]</span><br><span class="line">    k, bxs = tbls[i]</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k0 <span class="keyword">in</span> nomerge_lout_no:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> bxs[<span class="number">0</span>][<span class="string">&quot;page_number&quot;</span>] == bxs0[<span class="number">0</span>][<span class="string">&quot;page_number&quot;</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> bxs[<span class="number">0</span>][<span class="string">&quot;page_number&quot;</span>] - bxs0[<span class="number">0</span>][<span class="string">&quot;page_number&quot;</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    mh = <span class="variable language_">self</span>.mean_height[bxs[<span class="number">0</span>][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._y_dis(bxs0[-<span class="number">1</span>], bxs[<span class="number">0</span>]) &gt; mh * <span class="number">23</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    tables[k0].extend(tables[k])</span><br><span class="line">    <span class="keyword">del</span> tables[k]</span><br></pre></td></tr></table></figure>

<p>处理跨页表格的合并：</p>
<ol>
<li>按位置排序表格</li>
<li>检查相邻表格是否应该合并（同一页、相邻页、距离较近）</li>
<li>合并符合条件的跨页表格</li>
</ol>
<p><strong>标题匹配和提取</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find captions and pop out</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.boxes):</span><br><span class="line">    c = <span class="variable language_">self</span>.boxes[i]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> TableStructureRecognizer.is_caption(c):</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the nearest layouts</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nearest</span>(<span class="params">tbls</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> c</span><br><span class="line">        mink = <span class="string">&quot;&quot;</span></span><br><span class="line">        minv = <span class="number">1000000000</span></span><br><span class="line">        <span class="keyword">for</span> k, bxs <span class="keyword">in</span> tbls.items():</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> bxs:</span><br><span class="line">                <span class="keyword">if</span> b.get(<span class="string">&quot;layout_type&quot;</span>, <span class="string">&quot;&quot;</span>).find(<span class="string">&quot;caption&quot;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                y_dis = <span class="variable language_">self</span>._y_dis(c, b)</span><br><span class="line">                x_dis = <span class="variable language_">self</span>._x_dis(c, b) <span class="keyword">if</span> <span class="keyword">not</span> x_overlapped(c, b) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                dis = y_dis * y_dis + x_dis * x_dis</span><br><span class="line">                <span class="keyword">if</span> dis &lt; minv:</span><br><span class="line">                    mink = k</span><br><span class="line">                    minv = dis</span><br><span class="line">        <span class="keyword">return</span> mink, minv</span><br><span class="line"></span><br><span class="line">    tk, tv = nearest(tables)</span><br><span class="line">    fk, fv = nearest(figures)</span><br><span class="line">    <span class="keyword">if</span> tv &lt; fv <span class="keyword">and</span> tk:</span><br><span class="line">        tables[tk].insert(<span class="number">0</span>, c)</span><br><span class="line">        logging.debug(<span class="string">&quot;TABLE:&quot;</span> + <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;text&quot;</span>] + <span class="string">&quot;; Cap: &quot;</span> + tk)</span><br><span class="line">    <span class="keyword">elif</span> fk:</span><br><span class="line">        figures[fk].insert(<span class="number">0</span>, c)</span><br><span class="line">        logging.debug(<span class="string">&quot;FIGURE:&quot;</span> + <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;text&quot;</span>] + <span class="string">&quot;; Cap: &quot;</span> + tk)</span><br><span class="line">    <span class="variable language_">self</span>.boxes.pop(i)</span><br></pre></td></tr></table></figure>

<p>匹配并提取表格和图像的标题：</p>
<ol>
<li>识别标题类型的文本框</li>
<li>计算标题与表格&#x2F;图像的距离</li>
<li>将最近的标题添加到对应的表格或图像中</li>
</ol>
<p><strong>图像裁剪函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cropout</span>(<span class="params">bxs, ltype, poss</span>):</span><br><span class="line">    <span class="keyword">nonlocal</span> ZM</span><br><span class="line">    pn = <span class="built_in">set</span>([b[<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span> <span class="keyword">for</span> b <span class="keyword">in</span> bxs])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pn) &lt; <span class="number">2</span>:</span><br><span class="line">        pn = <span class="built_in">list</span>(pn)[<span class="number">0</span>]</span><br><span class="line">        ht = <span class="variable language_">self</span>.page_cum_height[pn]</span><br><span class="line">        b = &#123;</span><br><span class="line">            <span class="string">&quot;x0&quot;</span>: np.<span class="built_in">min</span>([b[<span class="string">&quot;x0&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> bxs]),</span><br><span class="line">            <span class="string">&quot;top&quot;</span>: np.<span class="built_in">min</span>([b[<span class="string">&quot;top&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> bxs]) - ht,</span><br><span class="line">            <span class="string">&quot;x1&quot;</span>: np.<span class="built_in">max</span>([b[<span class="string">&quot;x1&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> bxs]),</span><br><span class="line">            <span class="string">&quot;bottom&quot;</span>: np.<span class="built_in">max</span>([b[<span class="string">&quot;bottom&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> bxs]) - ht</span><br><span class="line">        &#125;</span><br><span class="line">        louts = [layout <span class="keyword">for</span> layout <span class="keyword">in</span> <span class="variable language_">self</span>.page_layout[pn] <span class="keyword">if</span> layout[<span class="string">&quot;type&quot;</span>] == ltype]</span><br><span class="line">        ii = Recognizer.find_overlapped(b, louts, naive=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> ii <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            b = louts[ii]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.warning(<span class="string">f&quot;Missing layout match: <span class="subst">&#123;pn + <span class="number">1</span>&#125;</span>,%s&quot;</span> % (bxs[<span class="number">0</span>].get(<span class="string">&quot;layoutno&quot;</span>, <span class="string">&quot;&quot;</span>)))</span><br><span class="line"></span><br><span class="line">        left, top, right, bott = b[<span class="string">&quot;x0&quot;</span>], b[<span class="string">&quot;top&quot;</span>], b[<span class="string">&quot;x1&quot;</span>], b[<span class="string">&quot;bottom&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">        poss.append((pn + <span class="variable language_">self</span>.page_from, left, right, top, bott))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.page_images[pn] \</span><br><span class="line">            .crop((left * ZM, top * ZM, right * ZM, bott * ZM))</span><br><span class="line">    <span class="comment"># ...处理跨页情况...</span></span><br></pre></td></tr></table></figure>

<p><code>cropout</code>)函数负责从页面图像中裁剪出表格或图像区域：</p>
<ol>
<li>计算包含所有文本框的边界框</li>
<li>查找对应的布局元素</li>
<li>裁剪图像区域并返回</li>
</ol>
<p><strong>结果构建和返回</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">positions = []</span><br><span class="line">figure_results = []</span><br><span class="line">figure_positions = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># crop figure out and add caption</span></span><br><span class="line"><span class="keyword">for</span> k, bxs <span class="keyword">in</span> figures.items():</span><br><span class="line">    txt = <span class="string">&quot;\n&quot;</span>.join([b[<span class="string">&quot;text&quot;</span>] <span class="keyword">for</span> b <span class="keyword">in</span> bxs])</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> txt:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    poss = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> separate_tables_figures:</span><br><span class="line">        figure_results.append((cropout(bxs, <span class="string">&quot;figure&quot;</span>, poss), [txt]))</span><br><span class="line">        figure_positions.append(poss)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append((cropout(bxs, <span class="string">&quot;figure&quot;</span>, poss), [txt]))</span><br><span class="line">        positions.append(poss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, bxs <span class="keyword">in</span> tables.items():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bxs:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    bxs = Recognizer.sort_Y_firstly(bxs, np.mean([(b[<span class="string">&quot;bottom&quot;</span>] - b[<span class="string">&quot;top&quot;</span>]) / <span class="number">2</span> <span class="keyword">for</span> b <span class="keyword">in</span> bxs]))</span><br><span class="line"></span><br><span class="line">    poss = []</span><br><span class="line"></span><br><span class="line">    res.append((cropout(bxs, <span class="string">&quot;table&quot;</span>, poss),</span><br><span class="line">                <span class="variable language_">self</span>.tbl_det.construct_table(bxs, html=return_html, is_english=<span class="variable language_">self</span>.is_english)))</span><br><span class="line">    positions.append(poss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> separate_tables_figures:</span><br><span class="line">    <span class="keyword">if</span> need_position:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(res, positions)), <span class="built_in">list</span>(<span class="built_in">zip</span>(figure_results, figure_positions))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res, figure_results</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> need_position:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(res, positions))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>构建最终结果：</p>
<ol>
<li>处理所有图像，裁剪图像区域并提取标题文本</li>
<li>处理所有表格，裁剪表格区域并构建表格数据</li>
<li>根据<code>separate_tables_figures</code>参数决定返回格式</li>
</ol>
<blockquote>
<p><strong>返回结果格式</strong></p>
<h4 id="分离模式-separate-tables-figures-True"><a href="#分离模式-separate-tables-figures-True" class="headerlink" title="分离模式 (separate_tables_figures=True)"></a>分离模式 (<code>separate_tables_figures=True</code>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tbls示例</span></span><br><span class="line">   tbls = [</span><br><span class="line">       (</span><br><span class="line">           &lt;PIL.Image.Image <span class="built_in">object</span>&gt;,  <span class="comment"># 包含表格图像的PIL对象</span></span><br><span class="line">           <span class="string">&quot;&quot;&quot;&lt;table&gt;</span></span><br><span class="line"><span class="string">                &lt;caption&gt;表1: 员工信息表&lt;/caption&gt;</span></span><br><span class="line"><span class="string">                &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;部门&lt;/th&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">                &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;28&lt;/td&gt;&lt;td&gt;技术部&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;市场部&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">           &lt;/table&gt;&quot;&quot;&quot;</span></span><br><span class="line">   )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># figures示例</span></span><br><span class="line">figures = [</span><br><span class="line">       (</span><br><span class="line">           &lt;PIL.Image.Image <span class="built_in">object</span>&gt;,  <span class="comment"># 包含图表图像的PIL对象</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;图1: 2023年销售趋势图&quot;</span>,</span><br><span class="line">           <span class="string">&quot;数据来源: 公司年度报告&quot;</span></span><br><span class="line">        ]</span><br><span class="line">   )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>统一模式 (<code>separate_tables_figures=False</code>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tbls示例</span></span><br><span class="line">tbls = [</span><br><span class="line">    (</span><br><span class="line">        &lt;PIL.Image.Image <span class="built_in">object</span>&gt;,  <span class="comment"># 包含图表图像的PIL对象</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;图1: 2023年销售趋势图&quot;</span>,</span><br><span class="line">            <span class="string">&quot;数据来源: 公司年度报告&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">   (</span><br><span class="line">        &lt;PIL.Image.Image <span class="built_in">object</span>&gt;,  <span class="comment"># 包含表格图像的PIL对象</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;&lt;table&gt;</span></span><br><span class="line"><span class="string">             &lt;caption&gt;表1: 员工信息表&lt;/caption&gt;</span></span><br><span class="line"><span class="string">            &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;部门&lt;/th&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;28&lt;/td&gt;&lt;td&gt;技术部&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">            &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;市场部&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">           &lt;/table&gt;&quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>在整个<code>PDF</code>解析流程中的作用</strong></p>
<ol>
<li><strong>内容提取</strong>：从文档中提取表格和图像内容</li>
<li><strong>结构化处理</strong>：将表格转换为结构化数据（HTML或文本列表）</li>
<li><strong>图像裁剪</strong>：提取表格和图像的图像区域</li>
<li><strong>标题关联</strong>：将标题与对应的表格&#x2F;图像关联</li>
<li><strong>跨页处理</strong>：处理跨页的表格和图像</li>
<li><strong>结果封装</strong>：将提取结果封装成统一格式返回</li>
</ol>
<p>这个方法是<code>RAGFlow</code>文档解析流程中的关键步骤，通过精细的处理确保表格和图像内容能够被准确提取和结构化表示。</p>
<hr>
<h3 id="self-concat-downward"><a href="#self-concat-downward" class="headerlink" title="self._concat_downward()"></a>self._concat_downward()</h3><p><code>_concat_downward</code>方法是<code>RAGFlow</code>的<code>PDF</code>解析流程中的纵向文本连接阶段，负责将逻辑上相关的文本行进行连接，形成更完整的段落。</p>
<p><strong>方法功能概述</strong></p>
<p>该方法的主要作用是：</p>
<ol>
<li><strong>纵向连接</strong>：将垂直方向上相邻且相关的文本框连接起来</li>
<li><strong>段落构建</strong>：构建完整的段落文本</li>
<li><strong>语义保持</strong>：确保连接后的文本在语义上是连贯的</li>
</ol>
<p><strong>详细实现分析</strong></p>
<ol>
<li>初始排序（但被注释掉了）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_concat_downward</span>(<span class="params">self, concat_between_pages=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="variable language_">self</span>.boxes = Recognizer.sort_Y_firstly(<span class="variable language_">self</span>.boxes, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># 这里直接返回了，所以实际没有执行下面的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># count boxes in the same row as a feature</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在当前实现中，这个方法实际上被注释掉了，只执行了按Y轴排序后就直接返回。这意味着纵向连接功能并未启用。</p>
<ol start="2">
<li>行内特征计算（如果启用的话）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># count boxes in the same row as a feature</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.boxes)):</span><br><span class="line">    mh = <span class="variable language_">self</span>.mean_height[<span class="variable language_">self</span>.boxes[i][<span class="string">&quot;page_number&quot;</span>] - <span class="number">1</span>]</span><br><span class="line">    <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;in_row&quot;</span>] = <span class="number">0</span></span><br><span class="line">    j = <span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">min</span>(i + <span class="number">12</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.boxes)):</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ydis = <span class="variable language_">self</span>._y_dis(<span class="variable language_">self</span>.boxes[i], <span class="variable language_">self</span>.boxes[j]) / mh</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(ydis) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>.boxes[i][<span class="string">&quot;in_row&quot;</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ydis &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果启用，这段代码会计算每个文本框在同一行中的其他文本框数量：</p>
<ul>
<li>计算垂直距离与平均高度的比值</li>
<li>如果比值小于1，认为在同一行</li>
<li>统计同一行中的文本框数量，存储在<code>in_row</code>字段中</li>
</ul>
<ol start="3">
<li>块分组算法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat between rows</span></span><br><span class="line">boxes = deepcopy(<span class="variable language_">self</span>.boxes)</span><br><span class="line">blocks = []</span><br><span class="line"><span class="keyword">while</span> boxes:</span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">up, dp</span>):</span><br><span class="line">        chunks.append(up)</span><br><span class="line">        i = dp</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">min</span>(dp + <span class="number">12</span>, <span class="built_in">len</span>(boxes)):</span><br><span class="line">            <span class="comment"># 多种连接条件判断</span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            fea = <span class="variable language_">self</span>._updown_concat_features(up, down)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.updown_cnt_mdl.predict(xgb.DMatrix([fea]))[<span class="number">0</span>] &lt;= <span class="number">0.5</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(down, i + <span class="number">1</span>)</span><br><span class="line">            boxes.pop(i)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    dfs(boxes[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    boxes.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> chunks:</span><br><span class="line">        blocks.append(chunks)</span><br></pre></td></tr></table></figure>

<p>使用深度优先搜索（DFS）算法将相关的文本框分组到块中：</p>
<ol>
<li><p>从第一个文本框开始，递归查找应该连接的文本框</p>
</li>
<li><p>使用机器学习模型判断两个文本框是否应该连接</p>
</li>
<li><p>将连接的文本框组成块（blocks）</p>
</li>
<li><p>特征提取和连接判断</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fea = <span class="variable language_">self</span>._updown_concat_features(up, down)</span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.updown_cnt_mdl.predict(xgb.DMatrix([fea]))[<span class="number">0</span>] &lt;= <span class="number">0.5</span>:</span><br><span class="line">    <span class="comment"># 不连接</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 连接</span></span><br></pre></td></tr></table></figure>

<p>使用<code>_updown_concat_features</code>方法提取特征，然后用XGBoost模型判断是否应该连接两个文本框。</p>
<ol start="5">
<li>特征提取方法详解</li>
</ol>
<p><code>_updown_concat_features</code>方法提取了30多个特征用于判断文本连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fea = [</span><br><span class="line">    up.get(<span class="string">&quot;R&quot;</span>, -<span class="number">1</span>) == down.get(<span class="string">&quot;R&quot;</span>, -<span class="number">1</span>),           <span class="comment"># 是否同一行</span></span><br><span class="line">    y_dis / h,                                      <span class="comment"># 垂直距离与高度比</span></span><br><span class="line">    down[<span class="string">&quot;page_number&quot;</span>] - up[<span class="string">&quot;page_number&quot;</span>],        <span class="comment"># 页码差</span></span><br><span class="line">    up[<span class="string">&quot;layout_type&quot;</span>] == down[<span class="string">&quot;layout_type&quot;</span>],       <span class="comment"># 是否相同布局类型</span></span><br><span class="line">    up[<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;text&quot;</span>,                    <span class="comment"># 上文本框是否为文本类型</span></span><br><span class="line">    down[<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;text&quot;</span>,                  <span class="comment"># 下文本框是否为文本类型</span></span><br><span class="line">    up[<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;table&quot;</span>,                   <span class="comment"># 上文本框是否为表格类型</span></span><br><span class="line">    down[<span class="string">&quot;layout_type&quot;</span>] == <span class="string">&quot;table&quot;</span>,                 <span class="comment"># 下文本框是否为表格类型</span></span><br><span class="line">    <span class="literal">True</span> <span class="keyword">if</span> re.search(<span class="string">r&quot;([。？！；!?;+)）]|[a-z]\.)$&quot;</span>, up[<span class="string">&quot;text&quot;</span>]) <span class="keyword">else</span> <span class="literal">False</span>,  <span class="comment"># 是否以句号结尾</span></span><br><span class="line">    <span class="literal">True</span> <span class="keyword">if</span> re.search(<span class="string">r&quot;[，：‘“、0-9（+-]$&quot;</span>, up[<span class="string">&quot;text&quot;</span>]) <span class="keyword">else</span> <span class="literal">False</span>,           <span class="comment"># 是否以逗号结尾</span></span><br><span class="line">    <span class="literal">True</span> <span class="keyword">if</span> re.search(<span class="string">r&quot;(^.?[/,?;:\]，。；：’”？！》】）-])&quot;</span>, down[<span class="string">&quot;text&quot;</span>]) <span class="keyword">else</span> <span class="literal">False</span>,  <span class="comment"># 下文本是否以标点开头</span></span><br><span class="line">    <span class="comment"># ... 还有20多个特征</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>块内文本连接</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat within each block</span></span><br><span class="line">boxes = []</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> blocks:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">1</span>:</span><br><span class="line">        boxes.append(b[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    t = b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> b[<span class="number">1</span>:]:</span><br><span class="line">        <span class="comment"># 连接文本</span></span><br><span class="line">        <span class="keyword">if</span> t[<span class="string">&quot;text&quot;</span>] <span class="keyword">and</span> re.<span class="keyword">match</span>(<span class="string">r&quot;[0-9\.a-zA-Z]+$&quot;</span>, t[<span class="string">&quot;text&quot;</span>][-<span class="number">1</span>] + c[<span class="string">&quot;text&quot;</span>][-<span class="number">1</span>]):</span><br><span class="line">            t[<span class="string">&quot;text&quot;</span>] += <span class="string">&quot; &quot;</span></span><br><span class="line">        t[<span class="string">&quot;text&quot;</span>] += c[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新边界框</span></span><br><span class="line">        t[<span class="string">&quot;x0&quot;</span>] = <span class="built_in">min</span>(t[<span class="string">&quot;x0&quot;</span>], c[<span class="string">&quot;x0&quot;</span>])</span><br><span class="line">        t[<span class="string">&quot;x1&quot;</span>] = <span class="built_in">max</span>(t[<span class="string">&quot;x1&quot;</span>], c[<span class="string">&quot;x1&quot;</span>])</span><br><span class="line">        t[<span class="string">&quot;page_number&quot;</span>] = <span class="built_in">min</span>(t[<span class="string">&quot;page_number&quot;</span>], c[<span class="string">&quot;page_number&quot;</span>])</span><br><span class="line">        t[<span class="string">&quot;bottom&quot;</span>] = c[<span class="string">&quot;bottom&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新布局类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t[<span class="string">&quot;layout_type&quot;</span>] <span class="keyword">and</span> c[<span class="string">&quot;layout_type&quot;</span>]:</span><br><span class="line">            t[<span class="string">&quot;layout_type&quot;</span>] = c[<span class="string">&quot;layout_type&quot;</span>]</span><br><span class="line">    boxes.append(t)</span><br></pre></td></tr></table></figure>

<p>将每个块内的文本框连接成一个完整的文本框：</p>
<ol>
<li>智能添加空格（避免数字和字母连在一起）</li>
<li>合并文本内容</li>
<li>更新边界框坐标</li>
<li>更新布局类型等属性</li>
</ol>
<blockquote>
<p>实际示例</p>
<p>假设有以下文本框序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接前</span></span><br><span class="line"><span class="variable language_">self</span>.boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;人工智能是计算机科学的一个分支，它企图了解智能的实质，&quot;</span>,</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">500</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">120</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;并生产出一种新的能以人类智能相似的方式做出反应的智能机器。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">500</span>, <span class="string">&quot;top&quot;</span>: <span class="number">125</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">145</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">500</span>, <span class="string">&quot;top&quot;</span>: <span class="number">150</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">170</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>经过<code>_concat_downward</code>处理后（如果启用）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接后</span></span><br><span class="line"><span class="variable language_">self</span>.boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;x0&quot;</span>: <span class="number">72</span>, <span class="string">&quot;x1&quot;</span>: <span class="number">500</span>, <span class="string">&quot;top&quot;</span>: <span class="number">100</span>, <span class="string">&quot;bottom&quot;</span>: <span class="number">170</span>,</span><br><span class="line">        <span class="string">&quot;page_number&quot;</span>: <span class="number">1</span>, <span class="string">&quot;layout_type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>在整个<code>PDF</code>解析流程中的作用</strong></p>
<ol>
<li><strong>文本连贯性</strong>：将逻辑上属于同一段落的文本行连接起来</li>
<li><strong>段落构建</strong>：构建完整的段落，提高文本可读性</li>
<li><strong>语义完整性</strong>：确保连接后的文本在语义上是完整的</li>
<li><strong>减少冗余</strong>：减少文本框数量，简化后续处理</li>
</ol>
<p><strong>当前状态分析</strong></p>
<p>从代码可以看出，<code>_concat_downward</code>方法目前并未实际执行，只进行了排序就返回了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_concat_downward</span>(<span class="params">self, concat_between_pages=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="variable language_">self</span>.boxes = Recognizer.sort_Y_firstly(<span class="variable language_">self</span>.boxes, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># 直接返回，下面的逻辑都被跳过了</span></span><br></pre></td></tr></table></figure>

<p>这可能是因为：</p>
<ol>
<li>纵向连接功能还在开发或测试中</li>
<li>发现该功能可能存在问题，暂时禁用</li>
<li>有性能考虑，暂时关闭该功能</li>
</ol>
<p><strong>设计考虑</strong></p>
<ol>
<li><strong>机器学习辅助</strong>：使用<code>XGBoost</code>模型判断文本连接，提高准确性</li>
<li><strong>多特征判断</strong>：考虑布局、位置、文本内容等多种因素</li>
<li><strong>跨页处理</strong>：支持跨页文本的连接处理</li>
<li><strong>标点符号处理</strong>：智能处理标点符号，确保连接后的文本语法正确</li>
</ol>
<p>这个方法体现了RAGFlow在文本处理方面的精细化设计，通过复杂的特征工程和机器学习模型，实现高质量的文本连接效果。</p>
<hr>
<h3 id="self-line-tag-最终return"><a href="#self-line-tag-最终return" class="headerlink" title="self._line_tag()  &amp; 最终return"></a>self._line_tag()  &amp; 最终return</h3><p><strong>最终返回内容详解</strong></p>
<p><strong>1.返回值结构</strong></p>
<p>根据不同的调用方式，有两种返回格式：</p>
<p><strong>分离模式（返回3个值）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls, figures</span><br></pre></td></tr></table></figure>

<p><strong>非分离模式（返回2个值）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes], tbls</span><br></pre></td></tr></table></figure>

<p><strong>2. 第一个返回值：文本内容和位置标签列表</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(b[<span class="string">&quot;text&quot;</span>], <span class="variable language_">self</span>._line_tag(b, zoomin)) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.boxes]</span><br></pre></td></tr></table></figure>

<p>这是主要的文本内容返回值，包含了文档中所有<strong>非表格、非图像的</strong>文本内容。</p>
<p><strong>数据结构：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    (                           <span class="comment"># 第一个文本元组</span></span><br><span class="line">        <span class="string">&quot;文本内容1&quot;</span>,              <span class="comment"># 纯文本内容</span></span><br><span class="line">        <span class="string">&quot;@@1\t100.0\t200.0\t50.0\t70.0##&quot;</span>  <span class="comment"># 位置标签</span></span><br><span class="line">    ),</span><br><span class="line">    (                           <span class="comment"># 第二个文本元组</span></span><br><span class="line">        <span class="string">&quot;文本内容2&quot;</span>,              <span class="comment"># 纯文本内容</span></span><br><span class="line">        <span class="string">&quot;@@1\t150.0\t300.0\t80.0\t100.0##&quot;</span> <span class="comment"># 位置标签</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t500.0\t100.0\t120.0##&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t500.0\t125.0\t145.0##&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;图1: 2023年销售趋势图显示销售额逐月增长。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@2\t100.0\t400.0\t200.0\t220.0##&quot;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>3. 位置标签 _line_tag详解</strong></p>
<p>位置标签格式：</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@页码-x0-x1-<span class="literal">top</span>-<span class="literal">bottom</span><span class="comment">##</span></span><br></pre></td></tr></table></figure>

<p><em>标签示例解析：</em>*</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;@@1\t72.0\t500.0\t100.0\t120.0##&quot;</span></span><br><span class="line"> || |  |     |     |      |</span><br><span class="line"> || |  |     |     |      └─ 底部坐标 (bottom)</span><br><span class="line"> || |  |     |     └─ 顶部坐标 (top)</span><br><span class="line"> || |  |     └─ 右边界坐标 (x1)</span><br><span class="line"> || |  └─ 左边界坐标 (x0)</span><br><span class="line"> || └─ 页码 (page_number)</span><br><span class="line"> └─ 标签标识符</span><br></pre></td></tr></table></figure>

<p><strong>跨页文本标签处理：</strong></p>
<p>对于跨页的文本框，标签会包含多个页码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;@@1-2\t72.0\t500.0\t100.0\t50.0##&quot;</span></span><br><span class="line">  || |          |</span><br><span class="line">  || └─ 页码<span class="number">1</span>-<span class="number">2</span>表示跨第<span class="number">1</span>页和第<span class="number">2</span>页</span><br><span class="line">  └─ 起始页码</span><br></pre></td></tr></table></figure>

<p><strong>4. 第二个返回值：表格（和图像）内容</strong></p>
<p>非分离模式下的<code>tbls</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tbls = [</span><br><span class="line">    (                           <span class="comment"># 图像内容</span></span><br><span class="line">        &lt;PIL图像对象&gt;,            <span class="comment"># 裁剪的图像</span></span><br><span class="line">        [<span class="string">&quot;图1: 销售趋势图&quot;</span>]        <span class="comment"># 图像标题列表</span></span><br><span class="line">    ),</span><br><span class="line">    (                           <span class="comment"># 表格内容</span></span><br><span class="line">        &lt;PIL图像对象&gt;,            <span class="comment"># 裁剪的表格图像</span></span><br><span class="line">        <span class="string">&quot;&lt;table&gt;...&lt;/table&gt;&quot;</span>     <span class="comment"># HTML格式表格数据</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>分离模式下的<code>tbls</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tbls = [</span><br><span class="line">    (                           <span class="comment"># 表格内容</span></span><br><span class="line">        &lt;PIL图像对象&gt;,            <span class="comment"># 裁剪的表格图像</span></span><br><span class="line">        <span class="string">&quot;&lt;table&gt;...&lt;/table&gt;&quot;</span>     <span class="comment"># HTML格式表格数据</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>5. 第三个返回值（仅在分离模式下）：图像内容</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">figures = [</span><br><span class="line">    (                           <span class="comment"># 图像内容</span></span><br><span class="line">        &lt;PIL图像对象&gt;,            <span class="comment"># 裁剪的图像</span></span><br><span class="line">        [<span class="string">&quot;图1: 销售趋势图&quot;</span>]        <span class="comment"># 图像标题列表</span></span><br><span class="line">    )</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>6.完整示例</strong></p>
<p>分离模式返回示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本内容和位置标签</span></span><br><span class="line">text_content = [</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;摘要：本文介绍了人工智能的发展历程和应用前景。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t500.0\t100.0\t120.0##&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;人工智能是计算机科学的一个重要分支...&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t500.0\t130.0\t150.0##&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;表1: 详细数据见下表。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t200.0\t200.0\t220.0##&quot;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表格内容</span></span><br><span class="line">tables = [</span><br><span class="line">    (</span><br><span class="line">        &lt;PIL图像对象&gt;,  <span class="comment"># 包含表格图像的PIL对象</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&lt;table&gt;</span></span><br><span class="line"><span class="string">             &lt;caption&gt;表1: 技术对比表&lt;/caption&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;th&gt;技术&lt;/th&gt;&lt;th&gt;优势&lt;/th&gt;&lt;th&gt;劣势&lt;/th&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;td&gt;机器学习&lt;/td&gt;&lt;td&gt;适应性强&lt;/td&gt;&lt;td&gt;需要大量数据&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">           &lt;/table&gt;&quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像内容</span></span><br><span class="line">figures = [</span><br><span class="line">    (</span><br><span class="line">        &lt;PIL图像对象&gt;,  <span class="comment"># 包含图表图像的PIL对象</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;图1: 人工智能发展时间线&quot;</span>,</span><br><span class="line">            <span class="string">&quot;数据来源: 统计年鉴&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终返回</span></span><br><span class="line"><span class="keyword">return</span> text_content, tables, figures</span><br></pre></td></tr></table></figure>

<p><strong>非分离模式返回示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本内容和位置标签（同上）</span></span><br><span class="line">text_content = [</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;摘要：本文介绍了人工智能的发展历程和应用前景。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@@1\t72.0\t500.0\t100.0\t120.0##&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合内容（表格和图像）</span></span><br><span class="line">mixed_content = [</span><br><span class="line">    (</span><br><span class="line">        &lt;PIL图像对象&gt;,  <span class="comment"># 图像对象</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;图1: 人工智能发展时间线&quot;</span>,</span><br><span class="line">            <span class="string">&quot;数据来源: 统计年鉴&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        &lt;PIL图像对象&gt;,  <span class="comment"># 表格图像对象</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&lt;table&gt;</span></span><br><span class="line"><span class="string">             &lt;caption&gt;表1: 技术对比表&lt;/caption&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;th&gt;技术&lt;/th&gt;&lt;th&gt;优势&lt;/th&gt;&lt;th&gt;劣势&lt;/th&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">             &lt;tr&gt;&lt;td&gt;机器学习&lt;/td&gt;&lt;td&gt;适应性强&lt;/td&gt;&lt;td&gt;需要大量数据&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">           &lt;/table&gt;&quot;&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终返回</span></span><br><span class="line"><span class="keyword">return</span> text_content, mixed_content</span><br></pre></td></tr></table></figure>

<p><strong>7. 各部分用途</strong></p>
<p><strong>文本内容和位置标签：</strong></p>
<ol>
<li><strong>文本内容</strong>：用于自然语言处理、信息检索、问答等</li>
<li><strong>位置标签</strong>：用于文档可视化、内容定位、高亮显示等</li>
</ol>
<p><strong>表格内容：</strong></p>
<ol>
<li><strong>表格图像</strong>：用于可视化展示原始表格</li>
<li><strong>HTML表格</strong>：用于结构化数据处理、数据分析等</li>
</ol>
<p><strong>图像内容：</strong></p>
<ol>
<li><strong>图像对象</strong>：用于可视化展示图表、图片等</li>
<li><strong>图像标题</strong>：用于理解图像内容、语义分析等</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们本文由总体到局部方法的介绍了<code>RAGFlow</code>中的<code>General</code>切分方式中的<code>PDF</code>解析部分，并给出了部分具象的输入前和输入后数据结构以供参考和理解。笔者认为解析过程中有几点需要注意：</p>
<ul>
<li><code>pdf</code>文本解析过程中使用了<code>pdfplumber</code>和<code>pypdf</code>，但都不是直接使用它们来进行内容的解析，都是为了辅助OCR识别的效果</li>
<li>英文<code>pdf</code>内容使用OCR来识别，不使用<code>pdfplumber</code>解析的内容来辅助OCR</li>
<li>对表格的提取得到的是HTML格式，图像是OCR提取图像上的文字（不使用视觉模型的情况下）</li>
<li>对表格数据进行向量化时使用的是HTML表格中的文本部分（经过一定处理），召回后使用的HTML格式</li>
<li>待续（想到再加）</li>
</ul>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/697902937">https://zhuanlan.zhihu.com/p/697902937</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/rag/" rel="tag"># rag</a>
              <a href="/tags/pdf/" rel="tag"># pdf</a>
              <a href="/tags/ragflow/" rel="tag"># ragflow</a>
              <a href="/tags/deepdoc/" rel="tag"># deepdoc</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/07/04/RAGFlow%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%97%AE%E9%A2%98%E7%AF%87/" rel="prev" title="RAGFlow使用技巧及问题篇">
                  <i class="fa fa-angle-left"></i> RAGFlow使用技巧及问题篇
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/07/07/TTS%E8%B0%83%E7%A0%94%E5%B0%8F%E8%AE%B0/" rel="next" title="TTS调研小记">
                  TTS调研小记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Chr</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">417k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:15</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","src":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
